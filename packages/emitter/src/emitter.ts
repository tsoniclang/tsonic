/**
 * Main C# Emitter - Public API
 * Orchestrates code generation from IR
 */

import { IrModule, Diagnostic } from "@tsonic/frontend";
import { EmitterOptions, JsonAotRegistry } from "./types.js";
import { emitModule } from "./core/module-emitter.js";
import { buildModuleMap } from "./core/module-map.js";

/**
 * Result of batch emission
 */
export type EmitResult =
  | { readonly ok: true; readonly files: Map<string, string> }
  | { readonly ok: false; readonly errors: readonly Diagnostic[] };

/**
 * Emit a complete C# file from an IR module
 */
export const emitCSharpFile = (
  module: IrModule,
  options: Partial<EmitterOptions> = {}
): string => {
  return emitModule(module, options);
};

/**
 * Batch emit multiple IR modules.
 * Returns an error if there are file name collisions after normalization.
 */
export const emitCSharpFiles = (
  modules: readonly IrModule[],
  options: Partial<EmitterOptions> = {}
): EmitResult => {
  // Build module map for cross-file import resolution
  const moduleMapResult = buildModuleMap(modules);

  if (!moduleMapResult.ok) {
    return { ok: false, errors: moduleMapResult.errors };
  }

  const moduleMap = moduleMapResult.value;
  const exportMap = moduleMapResult.exportMap;
  const results = new Map<string, string>();

  // Create JSON AOT registry (shared across all modules)
  const jsonAotRegistry: JsonAotRegistry = {
    rootTypes: new Set<string>(),
    needsJsonAot: false,
  };

  // Find common root directory for all modules
  const commonRoot = findCommonRoot(modules.map((m) => m.filePath));

  for (const module of modules) {
    // Create relative path from common root
    const relativePath = module.filePath.startsWith(commonRoot)
      ? module.filePath.slice(commonRoot.length).replace(/^\//, "")
      : module.filePath;
    const outputPath = relativePath.replace(/\.ts$/, ".cs");

    // Mark this module as entry point if it matches the entry point path
    const isEntryPoint = !!(
      options.entryPointPath && module.filePath === options.entryPointPath
    );
    const moduleOptions = {
      ...options,
      isEntryPoint,
      moduleMap, // Pass module map to each module emission
      exportMap, // Pass export map for re-export resolution
      jsonAotRegistry, // Pass JSON AOT registry for type collection
    };
    const code = emitModule(module, moduleOptions);
    results.set(outputPath, code);
  }

  // Generate __tsonic_json.g.cs if any JsonSerializer calls were detected
  if (jsonAotRegistry.needsJsonAot) {
    const rootNamespace = options.rootNamespace ?? "TsonicApp";
    const jsonCode = generateJsonAotFile(jsonAotRegistry, rootNamespace);
    results.set("__tsonic_json.g.cs", jsonCode);
  }

  return { ok: true, files: results };
};

/**
 * Generate the __tsonic_json.g.cs file for NativeAOT JSON support.
 * This file contains the JsonSerializerContext and options holder.
 */
const generateJsonAotFile = (
  registry: JsonAotRegistry,
  rootNamespace: string
): string => {
  const types = [...registry.rootTypes].sort();

  const attributes = types
    .map(
      (t) =>
        `    [global::System.Text.Json.Serialization.JsonSerializable(typeof(${t}))]`
    )
    .join("\n");

  return `// <auto-generated/>
// Generated by Tsonic for NativeAOT JSON serialization support
// WARNING: Do not modify this file manually

namespace ${rootNamespace}
{
    /// <summary>
    /// JsonSerializerContext for NativeAOT-compatible System.Text.Json serialization.
    /// Contains compile-time type metadata for all types used with JsonSerializer.
    /// </summary>
${attributes}
    internal partial class __TsonicJsonContext : global::System.Text.Json.Serialization.JsonSerializerContext { }

    /// <summary>
    /// Provides JsonSerializerOptions configured with the NativeAOT-compatible context.
    /// </summary>
    internal static class TsonicJson
    {
        internal static readonly global::System.Text.Json.JsonSerializerOptions Options = new global::System.Text.Json.JsonSerializerOptions
        {
            TypeInfoResolver = __TsonicJsonContext.Default
        };
    }
}
`;
};

/**
 * Find the common root directory for a set of file paths
 */
const findCommonRoot = (paths: readonly string[]): string => {
  if (paths.length === 0) return "";
  if (paths.length === 1) {
    const firstPath = paths[0];
    if (!firstPath) return "";
    const lastSlash = firstPath.lastIndexOf("/");
    return lastSlash >= 0 ? firstPath.slice(0, lastSlash + 1) : "";
  }

  // Split all paths into segments
  const segments = paths.map((p) => p.split("/"));
  const firstSegments = segments[0];
  if (!firstSegments) return "";

  const minLength = Math.min(...segments.map((s) => s.length));

  let commonLength = 0;
  for (let i = 0; i < minLength; i++) {
    const segment = firstSegments[i];
    if (segment && segments.every((s) => s[i] === segment)) {
      commonLength = i + 1;
    } else {
      break;
    }
  }

  return firstSegments.slice(0, commonLength).join("/") + "/";
};

// Re-export emitModule for backward compatibility
export { emitModule } from "./core/module-emitter.js";
