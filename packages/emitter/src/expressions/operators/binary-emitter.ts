/**
 * Binary operator expression emitter
 *
 * NEW NUMERIC SPEC:
 * - Literals use raw lexeme (no contextual widening)
 * - Integer casts only from IrCastExpression (not inferred from expectedType)
 * - Binary ops: int op int = int, double op anything = double (C# semantics)
 */

import { IrExpression, IrType } from "@tsonic/frontend";
import { EmitterContext, CSharpFragment } from "../../types.js";
import { emitExpression } from "../../expression-emitter.js";
import {
  resolveTypeAlias,
  stripNullish,
  getAllPropertySignatures,
  isDefinitelyValueType,
} from "../../core/semantic/type-resolution.js";
import {
  getPrecedence,
  isCharTyped,
  isStringTyped,
  getSingleCharLiteral,
  escapeCharLiteral,
  isNullishLiteral,
} from "./helpers.js";

/**
 * Emit a binary operator expression
 *
 * NEW NUMERIC SPEC: No contextual type propagation for numeric literals.
 * Literals use their raw lexeme - C# will naturally handle int + int = int,
 * int + double = double, etc.
 *
 * Explicit casts come from IrCastExpression nodes (generated by type-checker
 * when user intent allows int → double coercion).
 *
 * STRING INDEXER FIX: In C#, string[int] returns char, not string.
 * When comparing a string indexer result with a single-character string literal,
 * we emit the string as a char literal to avoid CS0019 (char == string).
 *
 * @param expr - The binary expression
 * @param context - Emitter context
 * @param _expectedType - Unused under new spec (kept for API compatibility)
 */
export const emitBinary = (
  expr: Extract<IrExpression, { kind: "binary" }>,
  context: EmitterContext,
  _expectedType?: IrType
): [CSharpFragment, EmitterContext] => {
  // Map JavaScript operators to C# operators
  const operatorMap: Record<string, string> = {
    "===": "==",
    "!==": "!=",
    "==": "==", // Loose equality - needs special handling
    "!=": "!=", // Loose inequality - needs special handling
    instanceof: "is",
    in: "/* in */", // Needs special handling
  };

  const op = operatorMap[expr.operator] ?? expr.operator;
  const parentPrecedence = getPrecedence(expr.operator);

  // Handle `"prop" in x` (union narrowing / dictionary membership)
  if (expr.operator === "in") {
    // LHS must be a string literal for deterministic lowering.
    if (expr.left.kind !== "literal" || typeof expr.left.value !== "string") {
      throw new Error(
        "ICE: Unsupported `in` operator form. Left-hand side must be a string literal."
      );
    }

    const rhsType = expr.right.inferredType;
    if (!rhsType) {
      throw new Error("ICE: `in` operator RHS missing inferredType.");
    }

    const [rhsFrag, rhsCtx] = emitExpression(expr.right, context);
    const rhsText = rhsFrag.text;

    const resolvedRhs = resolveTypeAlias(stripNullish(rhsType), rhsCtx);

    // Union<T1..Tn>: `"error" in auth` → auth.IsN() (where member N has the prop)
    if (resolvedRhs.kind === "unionType") {
      const propName = expr.left.value;
      const matchingMembers: number[] = [];

      for (let i = 0; i < resolvedRhs.types.length; i++) {
        const member = resolvedRhs.types[i];
        if (!member || member.kind !== "referenceType") continue;

        const localInfo = rhsCtx.localTypes?.get(member.name);
        if (localInfo?.kind === "interface") {
          const props = getAllPropertySignatures(member, rhsCtx);
          if (props?.some((p) => p.name === propName)) {
            matchingMembers.push(i + 1);
          }
          continue;
        }

        if (localInfo?.kind === "class") {
          if (
            localInfo.members.some(
              (m) =>
                (m.kind === "propertyDeclaration" ||
                  m.kind === "methodDeclaration") &&
                m.name === propName
            )
          ) {
            matchingMembers.push(i + 1);
          }
          continue;
        }

        // Cross-module union members: consult the batch type-member index.
        // This enables `"prop" in x` narrowing even when the union member types
        // are declared in a different TS module.
        const candidates: string[] = [];

        const stripGlobalPrefix = (name: string): string =>
          name.startsWith("global::") ? name.slice("global::".length) : name;

        if (member.resolvedClrType) {
          candidates.push(stripGlobalPrefix(member.resolvedClrType));
        }
        if (member.name.includes(".")) {
          candidates.push(member.name);
        }

        if (!member.name.includes(".") && rhsCtx.options.typeMemberIndex) {
          const matches: string[] = [];
          for (const fqn of rhsCtx.options.typeMemberIndex.keys()) {
            if (
              fqn.endsWith(`.${member.name}`) ||
              fqn.endsWith(`.${member.name}__Alias`)
            ) {
              matches.push(fqn);
            }
          }

          if (matches.length === 1) {
            candidates.push(matches[0]!);
          } else if (matches.length > 1) {
            const list = matches.sort().join(", ");
            throw new Error(
              `ICE: Ambiguous union member type '${member.name}' for \`in\` narrowing. Candidates: ${list}`
            );
          }
        }

        // Single-file fallback (no batch indexes): assume same namespace.
        if (rhsCtx.moduleNamespace) {
          candidates.push(`${rhsCtx.moduleNamespace}.${member.name}`);
          candidates.push(`${rhsCtx.moduleNamespace}.${member.name}__Alias`);
        }

        const hasMember = candidates.some((fqn) => {
          const perType = rhsCtx.options.typeMemberIndex?.get(fqn);
          return perType?.has(propName) ?? false;
        });

        if (hasMember) {
          matchingMembers.push(i + 1);
        }
      }

      if (matchingMembers.length === 0) {
        return [{ text: "false", precedence: parentPrecedence }, rhsCtx];
      }

      const checks = matchingMembers
        .map((n) => `${rhsText}.Is${n}()`)
        .join(" || ");
      // Lowering emits an `||` chain; wrap to preserve grouping in any surrounding expression.
      return [{ text: `(${checks})`, precedence: 16 }, rhsCtx];
    }

    // Dictionary<K,V>: `"k" in dict` → dict.ContainsKey("k")
    if (resolvedRhs.kind === "dictionaryType") {
      const keyType = stripNullish(resolvedRhs.keyType);
      const isStringKey =
        (keyType.kind === "primitiveType" && keyType.name === "string") ||
        (keyType.kind === "referenceType" && keyType.name === "string");

      if (!isStringKey) {
        throw new Error(
          "ICE: Unsupported `in` operator on dictionary with non-string keys."
        );
      }

      const [keyFrag, keyCtx] = emitExpression(expr.left, rhsCtx);
      const text = `${rhsText}.ContainsKey(${keyFrag.text})`;
      return [{ text, precedence: parentPrecedence }, keyCtx];
    }

    throw new Error(
      "ICE: Unsupported `in` operator. Only union shape guards and Dictionary<string, T> membership are supported."
    );
  }

  // Handle instanceof operator specially
  if (expr.operator === "instanceof") {
    const [leftFrag, leftContext] = emitExpression(expr.left, context);
    const [rightFrag, rightContext] = emitExpression(expr.right, leftContext);
    const text = `${leftFrag.text} is ${rightFrag.text}`;
    return [{ text, precedence: parentPrecedence }, rightContext];
  }

  // CHAR VS STRING COMPARISON FIX:
  // In C#, string[int] returns char, but in TypeScript it returns string.
  // The IR now sets inferredType to char for string indexer access.
  // When comparing a char-typed expression with a single-character string literal,
  // emit the string as a char literal to avoid CS0019 (operator == cannot be applied to char and string).
  const isComparisonOp =
    op === "==" ||
    op === "!=" ||
    op === "<" ||
    op === ">" ||
    op === "<=" ||
    op === ">=";

  if (isComparisonOp) {
    const leftIsChar = isCharTyped(expr.left);
    const rightIsChar = isCharTyped(expr.right);
    const leftSingleChar = getSingleCharLiteral(expr.left);
    const rightSingleChar = getSingleCharLiteral(expr.right);

    // Case 1: left is char-typed, right is single-char literal → emit right as char
    if (leftIsChar && rightSingleChar !== undefined) {
      const [leftFrag, leftContext] = emitExpression(expr.left, context);
      // Emit as char literal instead of string literal
      const charLiteral = `'${escapeCharLiteral(rightSingleChar)}'`;
      const text = `${leftFrag.text} ${op} ${charLiteral}`;
      return [{ text, precedence: parentPrecedence }, leftContext];
    }

    // Case 2: right is char-typed, left is single-char literal → emit left as char
    if (rightIsChar && leftSingleChar !== undefined) {
      const [rightFrag, rightContext] = emitExpression(expr.right, context);
      // Emit as char literal instead of string literal
      const charLiteral = `'${escapeCharLiteral(leftSingleChar)}'`;
      const text = `${charLiteral} ${op} ${rightFrag.text}`;
      return [{ text, precedence: parentPrecedence }, rightContext];
    }
  }

  // C# does not support relational operators directly on strings.
  // TypeScript's lexicographic ordering maps to ordinal string comparison.
  if (
    isComparisonOp &&
    (op === "<" || op === ">" || op === "<=" || op === ">=") &&
    isStringTyped(expr.left) &&
    isStringTyped(expr.right)
  ) {
    const [leftFrag, leftContext] = emitExpression(expr.left, context);
    const [rightFrag, rightContext] = emitExpression(expr.right, leftContext);
    const compareExpr = `global::System.String.CompareOrdinal(${leftFrag.text}, ${rightFrag.text})`;
    const text = `${compareExpr} ${op} 0`;
    return [{ text, precedence: getPrecedence(expr.operator) }, rightContext];
  }

  // NULLISH COMPARISONS:
  //
  // Prefer `== null` / `!= null` for normal reference/nullable types so the result
  // is expression-tree friendly (EF Core query providers do not support pattern matching).
  //
  // For unconstrained generics (T), `== null` is not always valid, so we instead cast
  // to `object` to force reference-equality semantics and avoid operator overloads:
  //   ((object)x) == null
  // This also avoids emitting pattern matching (`is null`) which is rejected inside
  // expression trees (EF Core query providers).
  //
  // TypeScript:  x === undefined  →  C#: x == null
  // TypeScript:  x !== undefined  →  C#: x != null
  // TypeScript:  x === null       →  C#: x == null
  // TypeScript:  x !== null       →  C#: x != null
  const leftIsNullish = isNullishLiteral(expr.left);
  const rightIsNullish = isNullishLiteral(expr.right);
  const isNullishComparison =
    isComparisonOp &&
    (op === "==" || op === "!=") &&
    (leftIsNullish || rightIsNullish);

  if (isNullishComparison) {
    // One side is null/undefined literal, emit the other side as a C# null check.
    // Clear narrowedBindings so we emit the raw identifier (not .Value)
    const nonNullishExpr = leftIsNullish ? expr.right : expr.left;
    const nullishExpr = leftIsNullish ? expr.left : expr.right;

    const isUndefinedLiteral =
      (nullishExpr.kind === "literal" && nullishExpr.value === undefined) ||
      (nullishExpr.kind === "identifier" && nullishExpr.name === "undefined");

    // JS dictionary-style access (`dict[key]`) with undefined comparison should
    // model key existence, not CLR value-type nullability.
    //
    //   dict[key] === undefined  -> !dict.ContainsKey(key)
    //   dict[key] !== undefined  ->  dict.ContainsKey(key)
    //
    // This prevents miscompiles like folding `dict[key] !== undefined` to `true`
    // when value type is non-nullable, and preserves delete/lookup behavior.
    if (
      isUndefinedLiteral &&
      nonNullishExpr.kind === "memberAccess" &&
      nonNullishExpr.isComputed &&
      typeof nonNullishExpr.property !== "string" &&
      (nonNullishExpr.accessKind === "dictionary" ||
        nonNullishExpr.object.inferredType?.kind === "dictionaryType")
    ) {
      const nonNullishContext = { ...context, narrowedBindings: undefined };
      const [dictFrag, dictContext] = emitExpression(
        nonNullishExpr.object,
        nonNullishContext
      );
      const [keyFrag, keyContext] = emitExpression(
        nonNullishExpr.property,
        dictContext
      );
      const containsExpr = `(${dictFrag.text}).ContainsKey(${keyFrag.text})`;
      const text = op === "==" ? `!${containsExpr}` : containsExpr;
      return [{ text, precedence: getPrecedence(expr.operator) }, keyContext];
    }

    const nonNullishContext = { ...context, narrowedBindings: undefined };
    const [nonNullishFrag, resultContext] = emitExpression(
      nonNullishExpr,
      nonNullishContext
    );

    const inferred = nonNullishExpr.inferredType;
    const base = inferred ? stripNullish(inferred) : undefined;
    const bareTypeParamName = (() => {
      if (!base) return undefined;
      if (base.kind === "typeParameterType") return base.name;
      if (
        base.kind === "referenceType" &&
        (resultContext.typeParameters?.has(base.name) ?? false) &&
        (!base.typeArguments || base.typeArguments.length === 0)
      ) {
        return base.name;
      }
      return undefined;
    })();

    const isDefiniteNonUnionValueType =
      inferred !== undefined &&
      inferred.kind !== "unionType" &&
      isDefinitelyValueType(inferred);

    const typeParamConstraint =
      bareTypeParamName !== undefined
        ? (resultContext.typeParamConstraints?.get(bareTypeParamName) ??
          "unconstrained")
        : undefined;

    const needsObjectCastForTypeParam =
      bareTypeParamName !== undefined &&
      (typeParamConstraint === "unconstrained" ||
        typeParamConstraint === "struct");
    const needsObjectCastForValueType = isDefiniteNonUnionValueType;

    const nullOp = op === "==" ? "== null" : "!= null";
    const nullOperandText = (() => {
      switch (nonNullishExpr.kind) {
        case "identifier":
        case "memberAccess":
        case "call":
        case "new":
        case "this":
        case "literal":
          return nonNullishFrag.text;
        default:
          return `(${nonNullishFrag.text})`;
      }
    })();
    const text =
      needsObjectCastForTypeParam || needsObjectCastForValueType
        ? `((global::System.Object)(${nonNullishFrag.text})) ${nullOp}`
        : `${nullOperandText} ${nullOp}`;

    return [{ text, precedence: getPrecedence(expr.operator) }, resultContext];
  }

  // Standard emission path
  // Emit operands without contextual type propagation
  // Literals will emit using their raw lexeme (42 vs 42.0)
  const [leftFrag, leftContext] = emitExpression(expr.left, context);
  const [rightFrag, rightContext] = emitExpression(expr.right, leftContext);

  // Wrap child expressions in parentheses if their precedence is lower than parent
  // This preserves grouping: (x + y) * z should not become x + y * z
  const leftText =
    leftFrag.precedence !== undefined && leftFrag.precedence < parentPrecedence
      ? `(${leftFrag.text})`
      : leftFrag.text;

  // For right operand, also wrap if precedence is equal (right-to-left associativity issue)
  // Example: a - (b - c) should not become a - b - c
  const rightText =
    rightFrag.precedence !== undefined &&
    rightFrag.precedence <= parentPrecedence
      ? `(${rightFrag.text})`
      : rightFrag.text;

  const text = `${leftText} ${op} ${rightText}`;

  return [{ text, precedence: getPrecedence(expr.operator) }, rightContext];
};
