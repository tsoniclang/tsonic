/**
 * Binary operator expression emitter
 *
 * NEW NUMERIC SPEC:
 * - Literals use raw lexeme (no contextual widening)
 * - Integer casts only from IrCastExpression (not inferred from expectedType)
 * - Binary ops: int op int = int, double op anything = double (C# semantics)
 */

import { IrExpression, IrType } from "@tsonic/frontend";
import { EmitterContext } from "../../types.js";
import { emitExpressionAst } from "../../expression-emitter.js";
import {
  resolveTypeAlias,
  stripNullish,
  getAllPropertySignatures,
  isDefinitelyValueType,
} from "../../core/semantic/type-resolution.js";
import {
  isCharTyped,
  isStringTyped,
  getSingleCharLiteral,
  escapeCharLiteral,
  isNullishLiteral,
} from "./helpers.js";
import { extractCalleeNameFromAst } from "../../core/format/backend-ast/utils.js";
import type { CSharpExpressionAst } from "../../core/format/backend-ast/types.js";

/**
 * Emit a binary operator expression as CSharpExpressionAst
 *
 * NEW NUMERIC SPEC: No contextual type propagation for numeric literals.
 * Literals use their raw lexeme - C# will naturally handle int + int = int,
 * int + double = double, etc.
 *
 * Explicit casts come from IrCastExpression nodes (generated by type-checker
 * when user intent allows int → double coercion).
 *
 * STRING INDEXER FIX: In C#, string[int] returns char, not string.
 * When comparing a string indexer result with a single-character string literal,
 * we emit the string as a char literal to avoid CS0019 (char == string).
 *
 * @param expr - The binary expression
 * @param context - Emitter context
 * @param _expectedType - Unused under new spec (kept for API compatibility)
 */
export const emitBinary = (
  expr: Extract<IrExpression, { kind: "binary" }>,
  context: EmitterContext,
  _expectedType?: IrType
): [CSharpExpressionAst, EmitterContext] => {
  // Map JavaScript operators to C# operators
  const operatorMap: Record<string, string> = {
    "===": "==",
    "!==": "!=",
    "==": "==", // Loose equality - needs special handling
    "!=": "!=", // Loose inequality - needs special handling
    instanceof: "is",
    in: "/* in */", // Needs special handling
  };

  const op = operatorMap[expr.operator] ?? expr.operator;

  // Handle `"prop" in x` (union narrowing / dictionary membership)
  if (expr.operator === "in") {
    // LHS must be a string literal for deterministic lowering.
    if (expr.left.kind !== "literal" || typeof expr.left.value !== "string") {
      throw new Error(
        "ICE: Unsupported `in` operator form. Left-hand side must be a string literal."
      );
    }

    const rhsType = expr.right.inferredType;
    if (!rhsType) {
      throw new Error("ICE: `in` operator RHS missing inferredType.");
    }

    const [rhsAst, rhsCtx] = emitExpressionAst(expr.right, context);

    const resolvedRhs = resolveTypeAlias(stripNullish(rhsType), rhsCtx);

    // Union<T1..Tn>: `"error" in auth` → auth.IsN() (where member N has the prop)
    if (resolvedRhs.kind === "unionType") {
      const propName = expr.left.value;
      const matchingMembers: number[] = [];

      for (let i = 0; i < resolvedRhs.types.length; i++) {
        const member = resolvedRhs.types[i];
        if (!member || member.kind !== "referenceType") continue;

        const localInfo = rhsCtx.localTypes?.get(member.name);
        if (localInfo?.kind === "interface") {
          const props = getAllPropertySignatures(member, rhsCtx);
          if (props?.some((p) => p.name === propName)) {
            matchingMembers.push(i + 1);
          }
          continue;
        }

        if (localInfo?.kind === "class") {
          if (
            localInfo.members.some(
              (m) =>
                (m.kind === "propertyDeclaration" ||
                  m.kind === "methodDeclaration") &&
                m.name === propName
            )
          ) {
            matchingMembers.push(i + 1);
          }
          continue;
        }

        // Cross-module union members: consult the batch type-member index.
        const candidates: string[] = [];

        const stripGlobalPrefix = (name: string): string =>
          name.startsWith("global::") ? name.slice("global::".length) : name;

        if (member.resolvedClrType) {
          candidates.push(stripGlobalPrefix(member.resolvedClrType));
        }
        if (member.name.includes(".")) {
          candidates.push(member.name);
        }

        if (!member.name.includes(".") && rhsCtx.options.typeMemberIndex) {
          const matches: string[] = [];
          for (const fqn of rhsCtx.options.typeMemberIndex.keys()) {
            if (
              fqn.endsWith(`.${member.name}`) ||
              fqn.endsWith(`.${member.name}__Alias`)
            ) {
              matches.push(fqn);
            }
          }

          if (matches.length === 1) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            candidates.push(matches[0]!);
          } else if (matches.length > 1) {
            const list = matches.sort().join(", ");
            throw new Error(
              `ICE: Ambiguous union member type '${member.name}' for \`in\` narrowing. Candidates: ${list}`
            );
          }
        }

        // Single-file fallback (no batch indexes): assume same namespace.
        if (rhsCtx.moduleNamespace) {
          candidates.push(`${rhsCtx.moduleNamespace}.${member.name}`);
          candidates.push(`${rhsCtx.moduleNamespace}.${member.name}__Alias`);
        }

        const hasMember = candidates.some((fqn) => {
          const perType = rhsCtx.options.typeMemberIndex?.get(fqn);
          return perType?.has(propName) ?? false;
        });

        if (hasMember) {
          matchingMembers.push(i + 1);
        }
      }

      if (matchingMembers.length === 0) {
        return [{ kind: "literalExpression", text: "false" }, rhsCtx];
      }

      // Build IsN() call ASTs and chain with ||
      const checkAsts: CSharpExpressionAst[] = matchingMembers.map(
        (n): CSharpExpressionAst => ({
          kind: "invocationExpression",
          expression: {
            kind: "memberAccessExpression",
            expression: rhsAst,
            memberName: `Is${n}`,
          },
          arguments: [],
        })
      );

      const orChain = checkAsts.reduce(
        (left, right): CSharpExpressionAst => ({
          kind: "binaryExpression",
          operatorToken: "||",
          left,
          right,
        })
      );

      // Wrap multi-member OR chains in parens so they compose correctly
      // with surrounding operators (e.g., `(x.Is1() || x.Is2()) && ok`).
      const result: CSharpExpressionAst =
        checkAsts.length > 1
          ? { kind: "parenthesizedExpression", expression: orChain }
          : orChain;

      return [result, rhsCtx];
    }

    // Dictionary<K,V>: `"k" in dict` → dict.ContainsKey("k")
    if (resolvedRhs.kind === "dictionaryType") {
      const keyType = stripNullish(resolvedRhs.keyType);
      const isStringKey =
        (keyType.kind === "primitiveType" && keyType.name === "string") ||
        (keyType.kind === "referenceType" && keyType.name === "string");

      if (!isStringKey) {
        throw new Error(
          "ICE: Unsupported `in` operator on dictionary with non-string keys."
        );
      }

      const [keyAst, keyCtx] = emitExpressionAst(expr.left, rhsCtx);
      const containsKeyAst: CSharpExpressionAst = {
        kind: "invocationExpression",
        expression: {
          kind: "memberAccessExpression",
          expression: rhsAst,
          memberName: "ContainsKey",
        },
        arguments: [keyAst],
      };
      return [containsKeyAst, keyCtx];
    }

    throw new Error(
      "ICE: Unsupported `in` operator. Only union shape guards and Dictionary<string, T> membership are supported."
    );
  }

  // Handle instanceof operator specially
  if (expr.operator === "instanceof") {
    const [leftAst, leftContext] = emitExpressionAst(expr.left, context);
    const [rightAst, rightContext] = emitExpressionAst(expr.right, leftContext);
    // For `is`, convert expression to type name (extract from identifierExpression)
    const rightText = extractCalleeNameFromAst(rightAst);
    const isExpr: CSharpExpressionAst = {
      kind: "isExpression",
      expression: leftAst,
      pattern: {
        kind: "typePattern",
        type: { kind: "identifierType", name: rightText },
      },
    };
    return [isExpr, rightContext];
  }

  // CHAR VS STRING COMPARISON FIX:
  // In C#, string[int] returns char, but in TypeScript it returns string.
  // When comparing a char-typed expression with a single-character string literal,
  // emit the string as a char literal to avoid CS0019 (char == string).
  const isComparisonOp =
    op === "==" ||
    op === "!=" ||
    op === "<" ||
    op === ">" ||
    op === "<=" ||
    op === ">=";

  if (isComparisonOp) {
    const leftIsChar = isCharTyped(expr.left);
    const rightIsChar = isCharTyped(expr.right);
    const leftSingleChar = getSingleCharLiteral(expr.left);
    const rightSingleChar = getSingleCharLiteral(expr.right);

    // Case 1: left is char-typed, right is single-char literal → emit right as char
    if (leftIsChar && rightSingleChar !== undefined) {
      const [leftAst, leftContext] = emitExpressionAst(expr.left, context);
      const charLiteralAst: CSharpExpressionAst = {
        kind: "literalExpression",
        text: `'${escapeCharLiteral(rightSingleChar)}'`,
      };
      return [
        {
          kind: "binaryExpression",
          operatorToken: op,
          left: leftAst,
          right: charLiteralAst,
        },
        leftContext,
      ];
    }

    // Case 2: right is char-typed, left is single-char literal → emit left as char
    if (rightIsChar && leftSingleChar !== undefined) {
      const [rightAst, rightContext] = emitExpressionAst(expr.right, context);
      const charLiteralAst: CSharpExpressionAst = {
        kind: "literalExpression",
        text: `'${escapeCharLiteral(leftSingleChar)}'`,
      };
      return [
        {
          kind: "binaryExpression",
          operatorToken: op,
          left: charLiteralAst,
          right: rightAst,
        },
        rightContext,
      ];
    }
  }

  // C# does not support relational operators directly on strings.
  // TypeScript's lexicographic ordering maps to ordinal string comparison.
  if (
    isComparisonOp &&
    (op === "<" || op === ">" || op === "<=" || op === ">=") &&
    isStringTyped(expr.left) &&
    isStringTyped(expr.right)
  ) {
    const [leftAst, leftContext] = emitExpressionAst(expr.left, context);
    const [rightAst, rightContext] = emitExpressionAst(expr.right, leftContext);
    const compareAst: CSharpExpressionAst = {
      kind: "invocationExpression",
      expression: {
        kind: "identifierExpression",
        identifier: "global::System.String.CompareOrdinal",
      },
      arguments: [leftAst, rightAst],
    };
    return [
      {
        kind: "binaryExpression",
        operatorToken: op,
        left: compareAst,
        right: { kind: "literalExpression", text: "0" },
      },
      rightContext,
    ];
  }

  // NULLISH COMPARISONS:
  //
  // Prefer `== null` / `!= null` for normal reference/nullable types so the result
  // is expression-tree friendly (EF Core query providers do not support pattern matching).
  //
  // For unconstrained generics (T), `== null` is not always valid, so we instead cast
  // to `object` to force reference-equality semantics and avoid operator overloads:
  //   ((object)x) == null
  //
  // TypeScript:  x === undefined  →  C#: x == null
  // TypeScript:  x !== undefined  →  C#: x != null
  // TypeScript:  x === null       →  C#: x == null
  // TypeScript:  x !== null       →  C#: x != null
  const leftIsNullish = isNullishLiteral(expr.left);
  const rightIsNullish = isNullishLiteral(expr.right);
  const isNullishComparison =
    isComparisonOp &&
    (op === "==" || op === "!=") &&
    (leftIsNullish || rightIsNullish);

  if (isNullishComparison) {
    // One side is null/undefined literal, emit the other side as a C# null check.
    // Clear narrowedBindings so we emit the raw identifier (not .Value)
    const nonNullishExpr = leftIsNullish ? expr.right : expr.left;
    const nullishExpr = leftIsNullish ? expr.left : expr.right;

    const isUndefinedLiteral =
      (nullishExpr.kind === "literal" && nullishExpr.value === undefined) ||
      (nullishExpr.kind === "identifier" && nullishExpr.name === "undefined");

    // JS dictionary-style access (`dict[key]`) with undefined comparison should
    // model key existence, not CLR value-type nullability.
    //
    //   dict[key] === undefined  -> !dict.ContainsKey(key)
    //   dict[key] !== undefined  ->  dict.ContainsKey(key)
    if (
      isUndefinedLiteral &&
      nonNullishExpr.kind === "memberAccess" &&
      nonNullishExpr.isComputed &&
      typeof nonNullishExpr.property !== "string" &&
      (nonNullishExpr.accessKind === "dictionary" ||
        nonNullishExpr.object.inferredType?.kind === "dictionaryType")
    ) {
      const nonNullishContext = { ...context, narrowedBindings: undefined };
      const [dictAst, dictContext] = emitExpressionAst(
        nonNullishExpr.object,
        nonNullishContext
      );
      const [keyAst, keyContext] = emitExpressionAst(
        nonNullishExpr.property,
        dictContext
      );
      const containsAst: CSharpExpressionAst = {
        kind: "invocationExpression",
        expression: {
          kind: "memberAccessExpression",
          expression: {
            kind: "parenthesizedExpression",
            expression: dictAst,
          },
          memberName: "ContainsKey",
        },
        arguments: [keyAst],
      };
      const resultAst: CSharpExpressionAst =
        op === "=="
          ? {
              kind: "prefixUnaryExpression",
              operatorToken: "!",
              operand: containsAst,
            }
          : containsAst;
      return [resultAst, keyContext];
    }

    const nonNullishContext = { ...context, narrowedBindings: undefined };
    const [nonNullishAst, resultContext] = emitExpressionAst(
      nonNullishExpr,
      nonNullishContext
    );

    const inferred = nonNullishExpr.inferredType;
    const base = inferred ? stripNullish(inferred) : undefined;
    const bareTypeParamName = (() => {
      if (!base) return undefined;
      if (base.kind === "typeParameterType") return base.name;
      if (
        base.kind === "referenceType" &&
        (resultContext.typeParameters?.has(base.name) ?? false) &&
        (!base.typeArguments || base.typeArguments.length === 0)
      ) {
        return base.name;
      }
      return undefined;
    })();

    const isDefiniteNonUnionValueType =
      inferred !== undefined &&
      inferred.kind !== "unionType" &&
      isDefinitelyValueType(inferred);

    const typeParamConstraint =
      bareTypeParamName !== undefined
        ? (resultContext.typeParamConstraints?.get(bareTypeParamName) ??
          "unconstrained")
        : undefined;

    const needsObjectCastForTypeParam =
      bareTypeParamName !== undefined &&
      (typeParamConstraint === "unconstrained" ||
        typeParamConstraint === "struct");
    const needsObjectCastForValueType = isDefiniteNonUnionValueType;

    const nullLiteral: CSharpExpressionAst = {
      kind: "literalExpression",
      text: "null",
    };
    const nullOp = op === "==" ? "==" : "!=";

    if (needsObjectCastForTypeParam || needsObjectCastForValueType) {
      // ((global::System.Object)(expr)) == null
      const castExpr: CSharpExpressionAst = {
        kind: "castExpression",
        type: { kind: "identifierType", name: "global::System.Object" },
        expression: {
          kind: "parenthesizedExpression",
          expression: nonNullishAst,
        },
      };
      return [
        {
          kind: "binaryExpression",
          operatorToken: nullOp,
          left: {
            kind: "parenthesizedExpression",
            expression: castExpr,
          },
          right: nullLiteral,
        },
        resultContext,
      ];
    }

    return [
      {
        kind: "binaryExpression",
        operatorToken: nullOp,
        left: nonNullishAst,
        right: nullLiteral,
      },
      resultContext,
    ];
  }

  // Standard emission path
  // Emit operands without contextual type propagation
  // Literals will emit using their raw lexeme (42 vs 42.0)
  // Parenthesization is handled by the printer's precedence system
  const [leftAst, leftContext] = emitExpressionAst(expr.left, context);
  const [rightAst, rightContext] = emitExpressionAst(expr.right, leftContext);

  return [
    {
      kind: "binaryExpression",
      operatorToken: op,
      left: leftAst,
      right: rightAst,
    },
    rightContext,
  ];
};
