/**
 * Operator expression emitters (binary, logical, unary, update, assignment, conditional)
 *
 * NEW NUMERIC SPEC:
 * - Literals use raw lexeme (no contextual widening)
 * - Integer casts only from IrCastExpression (not inferred from expectedType)
 * - Binary ops: int op int = int, double op anything = double (C# semantics)
 */

import { IrExpression, IrType, IrPattern } from "@tsonic/frontend";
import {
  EmitterContext,
  CSharpFragment,
  LocalTypeInfo,
  NarrowedBinding,
} from "../types.js";
import { emitExpression } from "../expression-emitter.js";
import { emitType } from "../type-emitter.js";
import {
  resolveTypeAlias,
  stripNullish,
  findUnionMemberIndex,
  getPropertyType,
  getAllPropertySignatures,
  isDefinitelyValueType,
} from "../core/type-resolution.js";
import { emitBooleanCondition } from "../core/boolean-context.js";
import { emitRemappedLocalName } from "../core/local-names.js";
import { lowerAssignmentPattern } from "../patterns.js";

/**
 * Check if an expression has proven Int32 type from the numeric proof pass.
 * Mirrors the same check in access.ts for consistency.
 */
const hasInt32Proof = (expr: IrExpression): boolean => {
  if (
    expr.inferredType?.kind === "primitiveType" &&
    expr.inferredType.name === "int"
  ) {
    return true;
  }
  if (
    expr.inferredType?.kind === "referenceType" &&
    expr.inferredType.name === "int"
  ) {
    return true;
  }
  return false;
};

/**
 * Get operator precedence for proper parenthesization
 */
const getPrecedence = (operator: string): number => {
  const precedences: Record<string, number> = {
    "||": 5,
    // C# precedence: `??` binds less tightly than `||` / `&&` but more tightly than `?:`.
    "??": 4,
    "&&": 6,
    "|": 7,
    "^": 8,
    "&": 9,
    "==": 10,
    "!=": 10,
    "===": 10,
    "!==": 10,
    "<": 11,
    ">": 11,
    "<=": 11,
    ">=": 11,
    instanceof: 11,
    in: 11,
    "<<": 12,
    ">>": 12,
    ">>>": 12,
    "+": 13,
    "-": 13,
    "*": 14,
    "/": 14,
    "%": 14,
    "**": 15,
  };

  return precedences[operator] ?? 16;
};

/**
 * Check if an expression has char type (either from string indexer or a variable typed as char).
 * In C#, string[int] returns char, not string like in TypeScript.
 * The IR now correctly sets inferredType to char for string indexer access.
 */
const isCharTyped = (expr: IrExpression): boolean => {
  return (
    (expr.inferredType?.kind === "primitiveType" &&
      expr.inferredType.name === "char") ||
    (expr.inferredType?.kind === "referenceType" &&
      expr.inferredType.name === "char")
  );
};

/**
 * Check if an expression is a single-character string literal.
 * Returns the character if so, undefined otherwise.
 */
const getSingleCharLiteral = (expr: IrExpression): string | undefined => {
  if (expr.kind !== "literal") return undefined;
  if (typeof expr.value !== "string") return undefined;
  if (expr.value.length !== 1) return undefined;
  return expr.value;
};

/**
 * Escape a character for use in a C# char literal.
 * Handles special characters like quotes, backslash, newline, etc.
 */
const escapeCharLiteral = (char: string): string => {
  switch (char) {
    case "'":
      return "\\'";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "\t":
      return "\\t";
    case "\0":
      return "\\0";
    default:
      return char;
  }
};

/**
 * Emit a binary operator expression
 *
 * NEW NUMERIC SPEC: No contextual type propagation for numeric literals.
 * Literals use their raw lexeme - C# will naturally handle int + int = int,
 * int + double = double, etc.
 *
 * Explicit casts come from IrCastExpression nodes (generated by type-checker
 * when user intent allows int → double coercion).
 *
 * STRING INDEXER FIX: In C#, string[int] returns char, not string.
 * When comparing a string indexer result with a single-character string literal,
 * we emit the string as a char literal to avoid CS0019 (char == string).
 *
 * @param expr - The binary expression
 * @param context - Emitter context
 * @param _expectedType - Unused under new spec (kept for API compatibility)
 */
export const emitBinary = (
  expr: Extract<IrExpression, { kind: "binary" }>,
  context: EmitterContext,
  _expectedType?: IrType
): [CSharpFragment, EmitterContext] => {
  // Map JavaScript operators to C# operators
  const operatorMap: Record<string, string> = {
    "===": "==",
    "!==": "!=",
    "==": "==", // Loose equality - needs special handling
    "!=": "!=", // Loose inequality - needs special handling
    instanceof: "is",
    in: "/* in */", // Needs special handling
  };

  const op = operatorMap[expr.operator] ?? expr.operator;
  const parentPrecedence = getPrecedence(expr.operator);

  // Handle `"prop" in x` (union narrowing / dictionary membership)
  if (expr.operator === "in") {
    // LHS must be a string literal for deterministic lowering.
    if (expr.left.kind !== "literal" || typeof expr.left.value !== "string") {
      throw new Error(
        "ICE: Unsupported `in` operator form. Left-hand side must be a string literal."
      );
    }

    const rhsType = expr.right.inferredType;
    if (!rhsType) {
      throw new Error("ICE: `in` operator RHS missing inferredType.");
    }

    const [rhsFrag, rhsCtx] = emitExpression(expr.right, context);
    const rhsText = rhsFrag.text;

    const resolvedRhs = resolveTypeAlias(stripNullish(rhsType), rhsCtx);

    // Union<T1..Tn>: `"error" in auth` → auth.IsN() (where member N has the prop)
    if (resolvedRhs.kind === "unionType") {
      const propName = expr.left.value;
      const matchingMembers: number[] = [];

      for (let i = 0; i < resolvedRhs.types.length; i++) {
        const member = resolvedRhs.types[i];
        if (!member || member.kind !== "referenceType") continue;

        const localInfo = rhsCtx.localTypes?.get(member.name);
        if (localInfo?.kind === "interface") {
          const props = getAllPropertySignatures(member, rhsCtx);
          if (props?.some((p) => p.name === propName)) {
            matchingMembers.push(i + 1);
          }
          continue;
        }

        if (localInfo?.kind === "class") {
          if (
            localInfo.members.some(
              (m) =>
                (m.kind === "propertyDeclaration" ||
                  m.kind === "methodDeclaration") &&
                m.name === propName
            )
          ) {
            matchingMembers.push(i + 1);
          }
          continue;
        }

        // Cross-module union members: consult the batch type-member index.
        // This enables `"prop" in x` narrowing even when the union member types
        // are declared in a different TS module.
        const candidates: string[] = [];

        const stripGlobalPrefix = (name: string): string =>
          name.startsWith("global::") ? name.slice("global::".length) : name;

        if (member.resolvedClrType) {
          candidates.push(stripGlobalPrefix(member.resolvedClrType));
        }
        if (member.name.includes(".")) {
          candidates.push(member.name);
        }

        if (!member.name.includes(".") && rhsCtx.options.typeMemberIndex) {
          const matches: string[] = [];
          for (const fqn of rhsCtx.options.typeMemberIndex.keys()) {
            if (
              fqn.endsWith(`.${member.name}`) ||
              fqn.endsWith(`.${member.name}__Alias`)
            ) {
              matches.push(fqn);
            }
          }

          if (matches.length === 1) {
            candidates.push(matches[0]!);
          } else if (matches.length > 1) {
            const list = matches.sort().join(", ");
            throw new Error(
              `ICE: Ambiguous union member type '${member.name}' for \`in\` narrowing. Candidates: ${list}`
            );
          }
        }

        // Single-file fallback (no batch indexes): assume same namespace.
        if (rhsCtx.moduleNamespace) {
          candidates.push(`${rhsCtx.moduleNamespace}.${member.name}`);
          candidates.push(`${rhsCtx.moduleNamespace}.${member.name}__Alias`);
        }

        const hasMember = candidates.some((fqn) => {
          const perType = rhsCtx.options.typeMemberIndex?.get(fqn);
          return perType?.has(propName) ?? false;
        });

        if (hasMember) {
          matchingMembers.push(i + 1);
        }
      }

      if (matchingMembers.length === 0) {
        return [{ text: "false", precedence: parentPrecedence }, rhsCtx];
      }

      const checks = matchingMembers
        .map((n) => `${rhsText}.Is${n}()`)
        .join(" || ");
      // Lowering emits an `||` chain; wrap to preserve grouping in any surrounding expression.
      return [{ text: `(${checks})`, precedence: 16 }, rhsCtx];
    }

    // Dictionary<K,V>: `"k" in dict` → dict.ContainsKey("k")
    if (resolvedRhs.kind === "dictionaryType") {
      const keyType = stripNullish(resolvedRhs.keyType);
      const isStringKey =
        (keyType.kind === "primitiveType" && keyType.name === "string") ||
        (keyType.kind === "referenceType" && keyType.name === "string");

      if (!isStringKey) {
        throw new Error(
          "ICE: Unsupported `in` operator on dictionary with non-string keys."
        );
      }

      const [keyFrag, keyCtx] = emitExpression(expr.left, rhsCtx);
      const text = `${rhsText}.ContainsKey(${keyFrag.text})`;
      return [{ text, precedence: parentPrecedence }, keyCtx];
    }

    throw new Error(
      "ICE: Unsupported `in` operator. Only union shape guards and Dictionary<string, T> membership are supported."
    );
  }

  // Handle instanceof operator specially
  if (expr.operator === "instanceof") {
    const [leftFrag, leftContext] = emitExpression(expr.left, context);
    const [rightFrag, rightContext] = emitExpression(expr.right, leftContext);
    const text = `${leftFrag.text} is ${rightFrag.text}`;
    return [{ text, precedence: parentPrecedence }, rightContext];
  }

  // CHAR VS STRING COMPARISON FIX:
  // In C#, string[int] returns char, but in TypeScript it returns string.
  // The IR now sets inferredType to char for string indexer access.
  // When comparing a char-typed expression with a single-character string literal,
  // emit the string as a char literal to avoid CS0019 (operator == cannot be applied to char and string).
  const isComparisonOp =
    op === "==" ||
    op === "!=" ||
    op === "<" ||
    op === ">" ||
    op === "<=" ||
    op === ">=";

  if (isComparisonOp) {
    const leftIsChar = isCharTyped(expr.left);
    const rightIsChar = isCharTyped(expr.right);
    const leftSingleChar = getSingleCharLiteral(expr.left);
    const rightSingleChar = getSingleCharLiteral(expr.right);

    // Case 1: left is char-typed, right is single-char literal → emit right as char
    if (leftIsChar && rightSingleChar !== undefined) {
      const [leftFrag, leftContext] = emitExpression(expr.left, context);
      // Emit as char literal instead of string literal
      const charLiteral = `'${escapeCharLiteral(rightSingleChar)}'`;
      const text = `${leftFrag.text} ${op} ${charLiteral}`;
      return [{ text, precedence: parentPrecedence }, leftContext];
    }

    // Case 2: right is char-typed, left is single-char literal → emit left as char
    if (rightIsChar && leftSingleChar !== undefined) {
      const [rightFrag, rightContext] = emitExpression(expr.right, context);
      // Emit as char literal instead of string literal
      const charLiteral = `'${escapeCharLiteral(leftSingleChar)}'`;
      const text = `${charLiteral} ${op} ${rightFrag.text}`;
      return [{ text, precedence: parentPrecedence }, rightContext];
    }
  }

  // NULLISH COMPARISONS:
  //
  // Prefer `== null` / `!= null` for normal reference/nullable types so the result
  // is expression-tree friendly (EF Core query providers do not support pattern matching).
  //
  // For unconstrained generics (T), `== null` is not always valid, so we instead cast
  // to `object` to force reference-equality semantics and avoid operator overloads:
  //   ((object)x) == null
  // This also avoids emitting pattern matching (`is null`) which is rejected inside
  // expression trees (EF Core query providers).
  //
  // TypeScript:  x === undefined  →  C#: x == null
  // TypeScript:  x !== undefined  →  C#: x != null
  // TypeScript:  x === null       →  C#: x == null
  // TypeScript:  x !== null       →  C#: x != null
  const isNullishLiteral = (e: IrExpression): boolean =>
    (e.kind === "literal" && (e.value === undefined || e.value === null)) ||
    (e.kind === "identifier" && (e.name === "undefined" || e.name === "null"));

  const leftIsNullish = isNullishLiteral(expr.left);
  const rightIsNullish = isNullishLiteral(expr.right);
  const isNullishComparison =
    isComparisonOp &&
    (op === "==" || op === "!=") &&
    (leftIsNullish || rightIsNullish);

  if (isNullishComparison) {
    // One side is null/undefined literal, emit the other side as a C# null check.
    // Clear narrowedBindings so we emit the raw identifier (not .Value)
    const nonNullishExpr = leftIsNullish ? expr.right : expr.left;
    const nonNullishContext = { ...context, narrowedBindings: undefined };
    const [nonNullishFrag, resultContext] = emitExpression(
      nonNullishExpr,
      nonNullishContext
    );

    const inferred = nonNullishExpr.inferredType;
    const base = inferred ? stripNullish(inferred) : undefined;
    const bareTypeParamName = (() => {
      if (!base) return undefined;
      if (base.kind === "typeParameterType") return base.name;
      if (
        base.kind === "referenceType" &&
        (resultContext.typeParameters?.has(base.name) ?? false) &&
        (!base.typeArguments || base.typeArguments.length === 0)
      ) {
        return base.name;
      }
      return undefined;
    })();

    // If the operand is definitely a non-nullable value type, fold comparison to a constant.
    if (
      inferred &&
      inferred.kind !== "unionType" &&
      isDefinitelyValueType(inferred)
    ) {
      const folded = op === "==" ? "false" : "true";
      return [
        { text: folded, precedence: getPrecedence(expr.operator) },
        resultContext,
      ];
    }

    const typeParamConstraint =
      bareTypeParamName !== undefined
        ? (resultContext.typeParamConstraints?.get(bareTypeParamName) ??
          "unconstrained")
        : undefined;

    if (typeParamConstraint === "struct") {
      const folded = op === "==" ? "false" : "true";
      return [
        { text: folded, precedence: getPrecedence(expr.operator) },
        resultContext,
      ];
    }

    const needsObjectCast =
      bareTypeParamName !== undefined &&
      typeParamConstraint === "unconstrained";

    const nullOp = op === "==" ? "== null" : "!= null";
    const nullOperandText = (() => {
      switch (nonNullishExpr.kind) {
        case "identifier":
        case "memberAccess":
        case "call":
        case "new":
        case "this":
        case "literal":
          return nonNullishFrag.text;
        default:
          return `(${nonNullishFrag.text})`;
      }
    })();
    const text = needsObjectCast
      ? `((global::System.Object)(${nonNullishFrag.text})) ${nullOp}`
      : `${nullOperandText} ${nullOp}`;

    return [{ text, precedence: getPrecedence(expr.operator) }, resultContext];
  }

  // Standard emission path
  // Emit operands without contextual type propagation
  // Literals will emit using their raw lexeme (42 vs 42.0)
  const [leftFrag, leftContext] = emitExpression(expr.left, context);
  const [rightFrag, rightContext] = emitExpression(expr.right, leftContext);

  // Wrap child expressions in parentheses if their precedence is lower than parent
  // This preserves grouping: (x + y) * z should not become x + y * z
  const leftText =
    leftFrag.precedence !== undefined && leftFrag.precedence < parentPrecedence
      ? `(${leftFrag.text})`
      : leftFrag.text;

  // For right operand, also wrap if precedence is equal (right-to-left associativity issue)
  // Example: a - (b - c) should not become a - b - c
  const rightText =
    rightFrag.precedence !== undefined &&
    rightFrag.precedence <= parentPrecedence
      ? `(${rightFrag.text})`
      : rightFrag.text;

  const text = `${leftText} ${op} ${rightText}`;

  return [{ text, precedence: getPrecedence(expr.operator) }, rightContext];
};

/**
 * Check if an IR type is boolean
 */
const isBooleanType = (type: IrExpression["inferredType"]): boolean => {
  if (!type) return false;
  return type.kind === "primitiveType" && type.name === "boolean";
};

/**
 * Emit a logical operator expression (&&, ||, ??)
 *
 * In TypeScript, || is used both for:
 * 1. Boolean OR (when operands are booleans)
 * 2. Nullish coalescing fallback (when left operand is nullable)
 *
 * In C#:
 * - || only works with booleans
 * - ?? is used for nullish coalescing
 *
 * We check if || is used with non-boolean operands and emit ?? instead.
 */
export const emitLogical = (
  expr: Extract<IrExpression, { kind: "logical" }>,
  context: EmitterContext
): [CSharpFragment, EmitterContext] => {
  const [leftFrag, leftContext] = emitExpression(expr.left, context);

  // If || is used with non-boolean left operand, use ?? instead for nullish coalescing
  const operator =
    expr.operator === "||" && !isBooleanType(expr.left.inferredType)
      ? "??"
      : expr.operator;

  const parentPrecedence = getPrecedence(operator);

  // If the left operand is a non-nullable value type, `??` is invalid in C# and the
  // fallback is unreachable. Emit only the left operand.
  if (
    operator === "??" &&
    expr.left.inferredType &&
    expr.left.inferredType.kind !== "unionType" &&
    isDefinitelyValueType(expr.left.inferredType) &&
    // Conditional access (`?.` / `?[`) produces nullable value types in C# even when the
    // underlying member type is non-nullable (e.g., `string?.Length` → `int?`).
    // In that case the fallback is still meaningful and must be preserved.
    !leftFrag.text.includes("?.") &&
    !leftFrag.text.includes("?[")
  ) {
    return [leftFrag, leftContext];
  }

  const [rightFrag, rightContext] = emitExpression(expr.right, leftContext);

  const leftText =
    leftFrag.precedence !== undefined && leftFrag.precedence < parentPrecedence
      ? `(${leftFrag.text})`
      : leftFrag.text;

  const rightText =
    rightFrag.precedence !== undefined &&
    rightFrag.precedence <= parentPrecedence
      ? `(${rightFrag.text})`
      : rightFrag.text;

  const text = `${leftText} ${operator} ${rightText}`;
  return [{ text, precedence: getPrecedence(operator) }, rightContext];
};

/**
 * Emit a unary operator expression (-, +, !, ~, typeof, void, delete)
 *
 * NEW NUMERIC SPEC: No contextual type propagation for numeric literals.
 * Explicit casts come from IrCastExpression nodes.
 *
 * @param expr - The unary expression
 * @param context - Emitter context
 * @param _expectedType - Unused under new spec (kept for API compatibility)
 */
export const emitUnary = (
  expr: Extract<IrExpression, { kind: "unary" }>,
  context: EmitterContext,
  expectedType?: IrType
): [CSharpFragment, EmitterContext] => {
  // In TypeScript, `!x` applies JS ToBoolean semantics to *any* operand.
  // In C#, `!` only works on booleans, so we must coerce to a boolean condition.
  if (expr.operator === "!") {
    const [condText, condCtx] = emitBooleanCondition(
      expr.expression,
      (e, ctx) => emitExpression(e, ctx),
      context
    );
    const text = `!(${condText})`;
    return [{ text, precedence: 15 }, condCtx];
  }

  const [operandFrag, newContext] = emitExpression(expr.expression, context);

  if (expr.operator === "typeof") {
    // typeof becomes global::Tsonic.Runtime.Operators.typeof()
    const text = `global::Tsonic.Runtime.Operators.@typeof(${operandFrag.text})`;
    return [{ text }, newContext];
  }

  if (expr.operator === "void") {
    // `void expr` evaluates `expr` and yields `undefined`.
    //
    // In expression position we must produce a value, so use an IIFE:
    //   (() => { <eval expr>; return default(<T>); })()
    //
    // In statement position, emitExpressionStatement handles this separately
    // (so we don't pay this cost for the common `void x;` marker).
    const operand = expr.expression;

    // If the operand is a literal null/undefined, evaluation is a no-op and can be skipped.
    // This avoids generating invalid discard assignments like `_ = default;`.
    const isNoopOperand =
      (operand.kind === "literal" &&
        (operand.value === undefined || operand.value === null)) ||
      (operand.kind === "identifier" &&
        (operand.name === "undefined" || operand.name === "null"));

    let currentContext = newContext;

    const effectiveExpectedType =
      expectedType &&
      expectedType.kind !== "voidType" &&
      expectedType.kind !== "neverType"
        ? expectedType
        : undefined;

    let returnTypeText = "object?";
    let defaultText = "default";
    if (effectiveExpectedType) {
      try {
        const [typeText, next] = emitType(
          effectiveExpectedType,
          currentContext
        );
        currentContext = next;
        returnTypeText = typeText;
        defaultText = `default(${typeText})`;
      } catch {
        // Fall back to object? + default literal.
      }
    }

    const operandStatement = (() => {
      if (isNoopOperand) return "";

      // If the operand is already a valid statement-expression (call/new/assignment/
      // update/await), emit it directly. Otherwise, use a discard assignment.
      if (
        operand.kind === "call" ||
        operand.kind === "new" ||
        operand.kind === "assignment" ||
        operand.kind === "update" ||
        operand.kind === "await"
      ) {
        return `${operandFrag.text}; `;
      }

      return `_ = ${operandFrag.text}; `;
    })();

    if (operand.kind === "await") {
      if (!currentContext.isAsync) {
        throw new Error(
          "ICE: `void await <expr>` reached emitter in a non-async context."
        );
      }

      const taskReturnType = `global::System.Threading.Tasks.Task<${returnTypeText}>`;
      const text = `await ((global::System.Func<${taskReturnType}>)(async () => { ${operandStatement}return ${defaultText}; }))()`;
      return [{ text }, currentContext];
    }

    const text = `((global::System.Func<${returnTypeText}>)(() => { ${operandStatement}return ${defaultText}; }))()`;
    return [{ text }, currentContext];
  }

  if (expr.operator === "delete") {
    // delete needs special handling
    const text = `/* delete ${operandFrag.text} */`;
    return [{ text }, newContext];
  }

  const text = `${expr.operator}${operandFrag.text}`;

  return [{ text, precedence: 15 }, newContext];
};

/**
 * Emit an update operator expression (++, --)
 */
export const emitUpdate = (
  expr: Extract<IrExpression, { kind: "update" }>,
  context: EmitterContext
): [CSharpFragment, EmitterContext] => {
  // Narrowing maps (instanceof / nullable / union) apply to *reads*, not writes.
  // For update operators, the operand is written, so we must not rewrite the target
  // identifier to a narrowed binding (e.g., C# pattern var).
  const operandCtx: EmitterContext =
    expr.expression.kind === "identifier" &&
    context.narrowedBindings?.has(expr.expression.name)
      ? (() => {
          const next = new Map(context.narrowedBindings);
          next.delete(expr.expression.name);
          return { ...context, narrowedBindings: next };
        })()
      : context;

  const [operandFrag, ctx] = emitExpression(expr.expression, operandCtx);
  const newContext: EmitterContext =
    operandCtx !== context
      ? { ...ctx, narrowedBindings: context.narrowedBindings }
      : ctx;

  const text = expr.prefix
    ? `${expr.operator}${operandFrag.text}`
    : `${operandFrag.text}${expr.operator}`;

  return [{ text, precedence: 15 }, newContext];
};

/**
 * Emit an assignment expression (=, +=, -=, etc.)
 *
 * Passes the LHS type as expected type to RHS, enabling proper integer
 * literal emission for cases like `this.value = this.value + 1`.
 */
export const emitAssignment = (
  expr: Extract<IrExpression, { kind: "assignment" }>,
  context: EmitterContext
): [CSharpFragment, EmitterContext] => {
  // Array element assignment uses native CLR indexer
  // HARD GATE: Index must be proven Int32 (validated by proof pass)
  if (
    expr.operator === "=" &&
    "kind" in expr.left &&
    expr.left.kind === "memberAccess" &&
    expr.left.isComputed &&
    expr.left.object.inferredType?.kind === "arrayType"
  ) {
    const leftExpr = expr.left as Extract<
      IrExpression,
      { kind: "memberAccess" }
    >;
    const indexExpr = leftExpr.property as IrExpression;

    if (!hasInt32Proof(indexExpr)) {
      // ICE: Unproven index should have been caught by proof pass (TSN5107)
      throw new Error(
        `Internal Compiler Error: Array index must be proven Int32. ` +
          `This should have been caught by the numeric proof pass (TSN5107).`
      );
    }

    const [objectFrag, objectContext] = emitExpression(
      leftExpr.object,
      context
    );
    const [indexFrag, indexContext] = emitExpression(indexExpr, objectContext);
    const [rightFrag, rightContext] = emitExpression(expr.right, indexContext);

    // Use native CLR indexer
    const text = `${objectFrag.text}[${indexFrag.text}] = ${rightFrag.text}`;
    return [{ text, precedence: 2 }, rightContext];
  }

  // Left side can be an expression or a pattern (for destructuring)
  const isPattern =
    "kind" in expr.left &&
    (expr.left.kind === "identifierPattern" ||
      expr.left.kind === "arrayPattern" ||
      expr.left.kind === "objectPattern");

  // Handle destructuring assignment patterns
  if (isPattern && expr.operator === "=") {
    const pattern = expr.left as IrPattern;

    // Emit the RHS first
    const [rightFrag, rightContext] = emitExpression(expr.right, context);

    // Use lowerAssignmentPattern to generate the destructuring expression
    const result = lowerAssignmentPattern(
      pattern,
      rightFrag.text,
      expr.right.inferredType,
      rightContext
    );

    return [{ text: result.expression, precedence: 2 }, result.context];
  }

  // Standard assignment (expression on left side)
  let leftText: string;
  let leftContext: EmitterContext;
  let leftType: IrType | undefined;

  if (isPattern) {
    // Identifier pattern with compound assignment (+=, etc.)
    const pattern = expr.left as IrPattern;
    if (pattern.kind === "identifierPattern") {
      leftText = emitRemappedLocalName(pattern.name, context);
      leftContext = context;
      leftType = pattern.type;
    } else {
      // Compound assignment to array/object pattern - not valid in JS
      leftText = "/* invalid compound destructuring */";
      leftContext = context;
    }
  } else {
    const leftExpr = expr.left as IrExpression;
    // Narrowing maps (instanceof / nullable / union) apply to *reads*, not writes.
    // For assignment, the LHS is written, so we must not rewrite identifier targets
    // to narrowed bindings (e.g., C# pattern vars).
    const leftCtx: EmitterContext =
      leftExpr.kind === "identifier" &&
      context.narrowedBindings?.has(leftExpr.name)
        ? (() => {
            const next = new Map(context.narrowedBindings);
            next.delete(leftExpr.name);
            return { ...context, narrowedBindings: next };
          })()
        : context;

    const [leftFrag, ctx] = emitExpression(leftExpr, leftCtx);
    leftText = leftFrag.text;
    // Restore narrowing for RHS emission (reads) when we suppressed it for the LHS.
    leftContext =
      leftCtx !== context
        ? { ...ctx, narrowedBindings: context.narrowedBindings }
        : ctx;
    leftType = leftExpr.inferredType;
  }

  // Pass LHS type as expected type to RHS for proper integer handling
  const [rightFrag, rightContext] = emitExpression(
    expr.right,
    leftContext,
    leftType
  );

  const text = `${leftText} ${expr.operator} ${rightFrag.text}`;
  return [{ text, precedence: 2 }, rightContext];
};

/**
 * Try to extract ternary guard info from a condition expression.
 * Handles both `isUser(x)` (positive) and `!isUser(x)` (negated).
 * Returns guard info with polarity indicating which branch to narrow.
 */
type TernaryGuardInfo = {
  readonly originalName: string;
  readonly memberN: number;
  readonly escapedOrig: string;
  readonly polarity: "positive" | "negative"; // positive = narrow whenTrue, negative = narrow whenFalse
};

const resolveLocalTypesForReference = (
  type: Extract<IrType, { kind: "referenceType" }>,
  context: EmitterContext
): ReadonlyMap<string, LocalTypeInfo> | undefined => {
  const lookupName = type.name.includes(".")
    ? (type.name.split(".").pop() ?? type.name)
    : type.name;

  if (context.localTypes?.has(lookupName)) {
    return context.localTypes;
  }

  const moduleMap = context.options.moduleMap;
  if (!moduleMap) return undefined;

  const matches: {
    readonly namespace: string;
    readonly localTypes: ReadonlyMap<string, LocalTypeInfo>;
  }[] = [];
  for (const m of moduleMap.values()) {
    if (!m.localTypes) continue;
    if (m.localTypes.has(lookupName)) {
      matches.push({ namespace: m.namespace, localTypes: m.localTypes });
    }
  }

  if (matches.length === 0) return undefined;
  if (matches.length === 1) return matches[0]!.localTypes;

  const fqn =
    type.resolvedClrType ?? (type.name.includes(".") ? type.name : undefined);
  if (fqn && fqn.includes(".")) {
    const ns = fqn.slice(0, fqn.lastIndexOf("."));
    const filtered = matches.filter((m) => m.namespace === ns);
    if (filtered.length === 1) return filtered[0]!.localTypes;
  }

  return undefined;
};

const tryGetLiteralSet = (
  type: IrType,
  context: EmitterContext
): ReadonlySet<string | number | boolean> | undefined => {
  const resolved = resolveTypeAlias(type, context);

  if (resolved.kind === "literalType") {
    return new Set([resolved.value]);
  }

  if (resolved.kind === "unionType") {
    const out = new Set<string | number | boolean>();
    for (const t of resolved.types) {
      const r = resolveTypeAlias(t, context);
      if (r.kind !== "literalType") return undefined;
      out.add(r.value);
    }
    return out;
  }

  return undefined;
};

const tryResolveTernaryGuard = (
  condition: IrExpression,
  context: EmitterContext
): TernaryGuardInfo | undefined => {
  // Check for direct call: isUser(x)
  const resolveFromCall = (
    call: Extract<IrExpression, { kind: "call" }>
  ): TernaryGuardInfo | undefined => {
    const narrowing = call.narrowing;
    if (!narrowing || narrowing.kind !== "typePredicate") return undefined;

    const arg = call.arguments[narrowing.argIndex];
    if (
      !arg ||
      ("kind" in arg && arg.kind === "spread") ||
      arg.kind !== "identifier"
    ) {
      return undefined;
    }

    const originalName = arg.name;
    const unionSourceType = arg.inferredType;
    if (!unionSourceType) return undefined;

    const resolved = resolveTypeAlias(stripNullish(unionSourceType), context);
    if (resolved.kind !== "unionType") return undefined;

    const idx = findUnionMemberIndex(resolved, narrowing.targetType, context);
    if (idx === undefined) return undefined;

    return {
      originalName,
      memberN: idx + 1,
      escapedOrig: emitRemappedLocalName(originalName, context),
      polarity: "positive",
    };
  };

  // Direct call: isUser(x) -> narrow whenTrue
  if (condition.kind === "call") {
    return resolveFromCall(condition);
  }

  // Discriminant literal equality: x.kind === "circle"
  const resolveFromDiscriminantEquality = (
    expr: IrExpression
  ): TernaryGuardInfo | undefined => {
    // Normalize `!(x.prop === lit)` to `x.prop !== lit` (and vice versa) by flipping polarity.
    if (expr.kind === "unary" && expr.operator === "!") {
      const inner = resolveFromDiscriminantEquality(expr.expression);
      if (!inner) return undefined;
      return {
        ...inner,
        polarity: inner.polarity === "positive" ? "negative" : "positive",
      };
    }

    if (expr.kind !== "binary") return undefined;
    if (
      expr.operator !== "===" &&
      expr.operator !== "!==" &&
      expr.operator !== "==" &&
      expr.operator !== "!="
    ) {
      return undefined;
    }

    const extract = (
      left: IrExpression,
      right: IrExpression
    ):
      | {
          readonly receiver: Extract<IrExpression, { kind: "identifier" }>;
          readonly propertyName: string;
          readonly literal: string | number | boolean;
        }
      | undefined => {
      if (left.kind !== "memberAccess") return undefined;
      if (left.isOptional) return undefined;
      if (left.isComputed) return undefined;
      if (left.object.kind !== "identifier") return undefined;
      if (typeof left.property !== "string") return undefined;
      if (right.kind !== "literal") return undefined;
      if (
        typeof right.value !== "string" &&
        typeof right.value !== "number" &&
        typeof right.value !== "boolean"
      ) {
        return undefined;
      }
      return {
        receiver: left.object,
        propertyName: left.property,
        literal: right.value,
      };
    };

    const direct = extract(expr.left, expr.right);
    const swapped = direct ? undefined : extract(expr.right, expr.left);
    const match = direct ?? swapped;
    if (!match) return undefined;

    const { receiver, propertyName, literal } = match;
    const originalName = receiver.name;

    if (context.narrowedBindings?.has(originalName)) return undefined;

    const unionSourceType = receiver.inferredType;
    if (!unionSourceType) return undefined;

    const resolved = resolveTypeAlias(stripNullish(unionSourceType), context);
    if (resolved.kind !== "unionType") return undefined;

    const unionArity = resolved.types.length;
    if (unionArity < 2 || unionArity > 8) return undefined;

    const matchingMembers: number[] = [];

    for (let i = 0; i < resolved.types.length; i++) {
      const member = resolved.types[i];
      if (!member) continue;

      let propType: IrType | undefined;

      if (member.kind === "objectType") {
        const prop = member.members.find(
          (m): m is Extract<typeof m, { kind: "propertySignature" }> =>
            m.kind === "propertySignature" && m.name === propertyName
        );
        propType = prop?.type;
      } else if (member.kind === "referenceType") {
        const localTypes = resolveLocalTypesForReference(member, context);
        if (!localTypes) continue;

        const lookupName = member.name.includes(".")
          ? (member.name.split(".").pop() ?? member.name)
          : member.name;

        propType = getPropertyType(
          { ...member, name: lookupName },
          propertyName,
          { ...context, localTypes }
        );
      } else {
        continue;
      }

      if (!propType) continue;

      const literals = tryGetLiteralSet(propType, context);
      if (!literals) continue;
      if (literals.has(literal)) {
        matchingMembers.push(i + 1);
      }
    }

    if (matchingMembers.length !== 1) return undefined;
    const memberN = matchingMembers[0];
    if (!memberN) return undefined;

    const isInequality = expr.operator === "!==" || expr.operator === "!=";

    return {
      originalName,
      memberN,
      escapedOrig: emitRemappedLocalName(originalName, context),
      polarity: isInequality ? "negative" : "positive",
    };
  };

  const discr = resolveFromDiscriminantEquality(condition);
  if (discr) return discr;

  // Negated call: !isUser(x) -> narrow whenFalse
  if (
    condition.kind === "unary" &&
    condition.operator === "!" &&
    condition.expression.kind === "call"
  ) {
    const guard = resolveFromCall(condition.expression);
    if (guard) {
      return { ...guard, polarity: "negative" };
    }
  }

  return undefined;
};

/**
 * Emit a conditional (ternary) expression
 *
 * Supports type predicate narrowing:
 * - `isUser(x) ? x.name : "anon"` → `x.Is1() ? (x.As1()).name : "anon"`
 * - `!isUser(x) ? "anon" : x.name` → `!x.Is1() ? "anon" : (x.As1()).name`
 *
 * @param expr - The conditional expression
 * @param context - Emitter context
 * @param expectedType - Optional expected type (for null → default in generic contexts)
 */
export const emitConditional = (
  expr: Extract<IrExpression, { kind: "conditional" }>,
  context: EmitterContext,
  expectedType?: IrType
): [CSharpFragment, EmitterContext] => {
  // When no contextual expectedType is provided (e.g., `var x = cond ? a : b`),
  // use the conditional expression's own inferred type to guide null/undefined → default
  // conversions and keep C# type inference consistent with TS.
  const branchExpectedType = expectedType ?? expr.inferredType;

  // Try to detect type predicate guard in condition
  const guard = tryResolveTernaryGuard(expr.condition, context);

  if (guard) {
    const { originalName, memberN, escapedOrig, polarity } = guard;

    // Build condition text
    const condText =
      polarity === "positive"
        ? `${escapedOrig}.Is${memberN}()`
        : `!${escapedOrig}.Is${memberN}()`;

    // Create inline narrowing binding: x -> (x.AsN())
    const inlineExpr = `(${escapedOrig}.As${memberN}())`;
    const narrowedMap = new Map<string, NarrowedBinding>(
      context.narrowedBindings ?? []
    );
    narrowedMap.set(originalName, { kind: "expr", exprText: inlineExpr });

    const narrowedContext: EmitterContext = {
      ...context,
      narrowedBindings: narrowedMap,
    };

    // Apply narrowing to the appropriate branch
    const [trueFrag, trueContext] =
      polarity === "positive"
        ? emitExpression(expr.whenTrue, narrowedContext, branchExpectedType)
        : emitExpression(expr.whenTrue, context, branchExpectedType);

    const [falseFrag, falseContext] =
      polarity === "negative"
        ? emitExpression(expr.whenFalse, narrowedContext, branchExpectedType)
        : emitExpression(expr.whenFalse, trueContext, branchExpectedType);

    const text = `${condText} ? ${trueFrag.text} : ${falseFrag.text}`;

    // Return context WITHOUT narrowing (don't leak)
    const finalContext: EmitterContext = {
      ...falseContext,
      narrowedBindings: context.narrowedBindings,
    };
    return [{ text, precedence: 3 }, finalContext];
  }

  // Standard ternary emission (no narrowing)
  const [condText, condContext] = emitBooleanCondition(
    expr.condition,
    (e, ctx) => emitExpression(e, ctx),
    context
  );

  // Pass expectedType (or inferred type) to both branches for null/undefined → default conversion
  const [trueFrag, trueContext] = emitExpression(
    expr.whenTrue,
    condContext,
    branchExpectedType
  );
  const [falseFrag, falseContext] = emitExpression(
    expr.whenFalse,
    trueContext,
    branchExpectedType
  );

  const text = `${condText} ? ${trueFrag.text} : ${falseFrag.text}`;
  return [{ text, precedence: 3 }, falseContext];
};
