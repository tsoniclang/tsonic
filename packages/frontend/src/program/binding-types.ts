/**
 * Binding manifest types - maps JS/TS names to CLR types/members
 * See spec/bindings.md for full manifest format
 */

/**
 * Parameter modifier for ref/out/in parameters
 * Matches the format from tsbindgen: { index: number, modifier: "ref" | "out" | "in" }
 */
export type ParameterModifier = {
  readonly index: number;
  readonly modifier: "ref" | "out" | "in";
};

/**
 * Member binding (method/property level)
 */
export type MemberBinding = {
  readonly kind: "method" | "property";
  readonly signature?: string; // Optional TS signature for diagnostics
  /** Total CLR parameter count (includes extension receiver for extension methods). */
  readonly parameterCount?: number;
  readonly name: string; // CLR member name (e.g., "SelectMany")
  readonly alias: string; // TS identifier (e.g., "selectMany")
  readonly binding: {
    readonly assembly: string;
    readonly type: string; // Full CLR type (e.g., "System.Linq.Enumerable")
    readonly member: string; // CLR member name
  };
  // Parameter modifiers for ref/out/in parameters (from tsbindgen)
  readonly parameterModifiers?: readonly ParameterModifier[];
  // Whether this member is an extension method (tsbindgen metadata).
  // Used by the emitter to lower instance-style calls to explicit static calls.
  readonly isExtensionMethod?: boolean;
};

/**
 * Type binding (class/interface/struct/enum level)
 */
export type TypeBinding = {
  readonly name: string; // CLR type name (e.g., "Enumerable")
  readonly alias: string; // TS identifier (e.g., "enumerable")
  readonly kind: "class" | "interface" | "struct" | "enum";
  readonly members: readonly MemberBinding[];
};

/**
 * Namespace binding
 */
export type NamespaceBinding = {
  readonly name: string; // CLR namespace (e.g., "System.Linq")
  readonly alias: string; // TS identifier (e.g., "systemLinq")
  readonly types: readonly TypeBinding[];
};

/**
 * Full binding manifest structure (new format from bindings.md)
 */
export type FullBindingManifest = {
  readonly assembly: string;
  readonly namespaces: readonly NamespaceBinding[];
};

/**
 * Simple binding entry for global/module identifiers
 * Maps identifiers like `console`, `Math`, `fs` to CLR types
 */
export type SimpleBindingDescriptor = {
  readonly kind: "global" | "module";
  readonly assembly: string;
  readonly type: string;
  readonly csharpName?: string; // Optional: rename identifier in generated C#
};

/**
 * Simple binding file structure for global/module bindings
 */
export type SimpleBindingFile = {
  readonly bindings: Readonly<Record<string, SimpleBindingDescriptor>>;
};

/**
 * tsbindgen format - generated by tsbindgen tool
 * This is the format produced when generating bindings from .NET assemblies
 */
export type TsbindgenMethod = {
  readonly clrName: string;
  /** Normalized signature string (tsbindgen metadata, used for extension receiver inference) */
  readonly normalizedSignature?: string;
  /** Total parameter count in CLR signature (includes extension receiver) */
  readonly parameterCount?: number;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
  // Parameter modifiers for ref/out/in parameters
  readonly parameterModifiers?: readonly ParameterModifier[];
  readonly isExtensionMethod?: boolean;
};

export type TsbindgenProperty = {
  readonly clrName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenField = {
  readonly clrName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenTypeRef = {
  readonly stableId?: string;
  readonly clrName: string;
  readonly typeArguments?: readonly string[];
};

export type TsbindgenType = {
  readonly clrName: string; // Full CLR type name (e.g., "System.Console")
  readonly assemblyName: string;
  readonly baseType?: TsbindgenTypeRef;
  readonly interfaces?: readonly TsbindgenTypeRef[];
  /**
   * CLR type kind from tsbindgen (e.g., "Class", "Interface", "Struct", "Enum").
   *
   * This is used for airplane-grade emission decisions (e.g., whether a name in
   * a TS `implements` clause is a CLR interface and should be emitted in the C#
   * heritage list).
   */
  readonly kind?: "Class" | "Interface" | "Struct" | "Enum";
  readonly methods: readonly TsbindgenMethod[];
  readonly properties: readonly TsbindgenProperty[];
  readonly fields: readonly TsbindgenField[];
};

/**
 * tsbindgen "flattened named export" descriptor.
 *
 * This is an additive surface to support JS-style named imports that bind to
 * a stable declaring CLR type + member (typically module container static types).
 *
 * Example (user code):
 *   import { buildSite } from "@tsumo/engine/Tsumo.Engine.js";
 *   buildSite(req);
 *
 * Example (bindings.json excerpt):
 *   "exports": {
 *     "buildSite": {
 *       "kind": "method",
 *       "clrName": "buildSite",
 *       "declaringClrType": "Tsumo.Engine.BuildSite",
 *       "declaringAssemblyName": "Tsumo.Engine"
 *     }
 *   }
 */
export type TsbindgenExport = {
  readonly kind: "method" | "property" | "field";
  readonly clrName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenBindingFile = {
  readonly namespace: string;
  readonly types: readonly TsbindgenType[];
  readonly exports?: Readonly<Record<string, TsbindgenExport>>;
};

/**
 * Union type for all binding formats
 */
export type BindingFile =
  | FullBindingManifest
  | SimpleBindingFile
  | TsbindgenBindingFile;

/**
 * Type guard to check if a manifest is the full format
 */
export const isFullBindingManifest = (
  manifest: BindingFile
): manifest is FullBindingManifest => {
  return "assembly" in manifest && "namespaces" in manifest;
};

/**
 * Type guard to check if a manifest is the tsbindgen format
 */
export const isTsbindgenBindingFile = (
  manifest: BindingFile
): manifest is TsbindgenBindingFile => {
  return (
    "namespace" in manifest &&
    "types" in manifest &&
    !("namespaces" in manifest)
  );
};

/**
 * Validate that a parsed JSON object is a valid binding file format.
 * Returns an error message if invalid, undefined if valid.
 */
export const validateBindingFile = (
  obj: unknown,
  filePath: string
): string | undefined => {
  if (obj === null || typeof obj !== "object") {
    return `${filePath}: Expected object, got ${typeof obj}`;
  }

  const manifest = obj as Record<string, unknown>;

  // Check for tsbindgen format
  if ("namespace" in manifest && "types" in manifest) {
    if (typeof manifest.namespace !== "string") {
      return `${filePath}: 'namespace' must be a string`;
    }
    if (!Array.isArray(manifest.types)) {
      return `${filePath}: 'types' must be an array`;
    }
    return undefined; // Valid tsbindgen format
  }

  // Check for full manifest format
  if ("assembly" in manifest && "namespaces" in manifest) {
    if (typeof manifest.assembly !== "string") {
      return `${filePath}: 'assembly' must be a string`;
    }
    if (!Array.isArray(manifest.namespaces)) {
      return `${filePath}: 'namespaces' must be an array`;
    }
    return undefined; // Valid full format
  }

  // Check for simple format (global/module bindings)
  if ("bindings" in manifest) {
    if (typeof manifest.bindings !== "object" || manifest.bindings === null) {
      return `${filePath}: 'bindings' must be an object`;
    }
    return undefined; // Valid simple format
  }

  return `${filePath}: Unrecognized binding file format. Expected tsbindgen (namespace+types), full (assembly+namespaces), or simple (bindings) format.`;
};
