/**
 * Binding manifest loading - maps JS/TS names to CLR types/members
 * See spec/bindings.md for full manifest format
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { tsbindgenClrTypeNameToTsTypeName } from "../tsbindgen/names.js";

/**
 * Parameter modifier for ref/out/in parameters
 * Matches the format from tsbindgen: { index: number, modifier: "ref" | "out" | "in" }
 */
export type ParameterModifier = {
  readonly index: number;
  readonly modifier: "ref" | "out" | "in";
};

/**
 * Member binding (method/property level)
 */
export type MemberBinding = {
  readonly kind: "method" | "property";
  readonly signature?: string; // Optional TS signature for diagnostics
  /** Total CLR parameter count (includes extension receiver for extension methods). */
  readonly parameterCount?: number;
  readonly name: string; // CLR member name (e.g., "SelectMany")
  readonly alias: string; // TS identifier (e.g., "selectMany")
  readonly binding: {
    readonly assembly: string;
    readonly type: string; // Full CLR type (e.g., "System.Linq.Enumerable")
    readonly member: string; // CLR member name
  };
  // Parameter modifiers for ref/out/in parameters (from tsbindgen)
  readonly parameterModifiers?: readonly ParameterModifier[];
  // Whether this member is an extension method (tsbindgen metadata).
  // Used by the emitter to lower instance-style calls to explicit static calls.
  readonly isExtensionMethod?: boolean;
};

/**
 * Type binding (class/interface/struct/enum level)
 */
export type TypeBinding = {
  readonly name: string; // CLR type name (e.g., "Enumerable")
  readonly alias: string; // TS identifier (e.g., "enumerable")
  readonly kind: "class" | "interface" | "struct" | "enum";
  readonly members: readonly MemberBinding[];
};

/**
 * Namespace binding
 */
export type NamespaceBinding = {
  readonly name: string; // CLR namespace (e.g., "System.Linq")
  readonly alias: string; // TS identifier (e.g., "systemLinq")
  readonly types: readonly TypeBinding[];
};

/**
 * Full binding manifest structure (new format from bindings.md)
 */
export type FullBindingManifest = {
  readonly assembly: string;
  readonly namespaces: readonly NamespaceBinding[];
};

/**
 * Simple binding entry for global/module identifiers
 * Maps identifiers like `console`, `Math`, `fs` to CLR types
 */
export type SimpleBindingDescriptor = {
  readonly kind: "global" | "module";
  readonly assembly: string;
  readonly type: string;
  readonly csharpName?: string; // Optional: rename identifier in generated C#
};

/**
 * Simple binding file structure for global/module bindings
 */
export type SimpleBindingFile = {
  readonly bindings: Readonly<Record<string, SimpleBindingDescriptor>>;
};

/**
 * tsbindgen format - generated by tsbindgen tool
 * This is the format produced when generating bindings from .NET assemblies
 */
export type TsbindgenMethod = {
  readonly clrName: string;
  /** Normalized signature string (tsbindgen metadata, used for extension receiver inference) */
  readonly normalizedSignature?: string;
  /** Total parameter count in CLR signature (includes extension receiver) */
  readonly parameterCount?: number;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
  // Parameter modifiers for ref/out/in parameters
  readonly parameterModifiers?: readonly ParameterModifier[];
  readonly isExtensionMethod?: boolean;
};

export type TsbindgenProperty = {
  readonly clrName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenField = {
  readonly clrName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenTypeRef = {
  readonly stableId?: string;
  readonly clrName: string;
  readonly typeArguments?: readonly string[];
};

export type TsbindgenType = {
  readonly clrName: string; // Full CLR type name (e.g., "System.Console")
  readonly assemblyName: string;
  readonly baseType?: TsbindgenTypeRef;
  readonly interfaces?: readonly TsbindgenTypeRef[];
  /**
   * CLR type kind from tsbindgen (e.g., "Class", "Interface", "Struct", "Enum").
   *
   * This is used for airplane-grade emission decisions (e.g., whether a name in
   * a TS `implements` clause is a CLR interface and should be emitted in the C#
   * heritage list).
   */
  readonly kind?: "Class" | "Interface" | "Struct" | "Enum";
  readonly methods: readonly TsbindgenMethod[];
  readonly properties: readonly TsbindgenProperty[];
  readonly fields: readonly TsbindgenField[];
};

/**
 * tsbindgen "flattened named export" descriptor.
 *
 * This is an additive surface to support JS-style named imports that bind to
 * a stable declaring CLR type + member (typically module container static types).
 *
 * Example (user code):
 *   import { buildSite } from "@tsumo/engine/Tsumo.Engine.js";
 *   buildSite(req);
 *
 * Example (bindings.json excerpt):
 *   "exports": {
 *     "buildSite": {
 *       "kind": "method",
 *       "clrName": "buildSite",
 *       "declaringClrType": "Tsumo.Engine.BuildSite",
 *       "declaringAssemblyName": "Tsumo.Engine"
 *     }
 *   }
 */
export type TsbindgenExport = {
  readonly kind: "method" | "property" | "field";
  readonly clrName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenBindingFile = {
  readonly namespace: string;
  readonly types: readonly TsbindgenType[];
  readonly exports?: Readonly<Record<string, TsbindgenExport>>;
};

/**
 * Union type for all binding formats
 */
export type BindingFile =
  | FullBindingManifest
  | SimpleBindingFile
  | TsbindgenBindingFile;

/**
 * Type guard to check if a manifest is the full format
 */
const isFullBindingManifest = (
  manifest: BindingFile
): manifest is FullBindingManifest => {
  return "assembly" in manifest && "namespaces" in manifest;
};

/**
 * Type guard to check if a manifest is the tsbindgen format
 */
const isTsbindgenBindingFile = (
  manifest: BindingFile
): manifest is TsbindgenBindingFile => {
  return (
    "namespace" in manifest &&
    "types" in manifest &&
    !("namespaces" in manifest)
  );
};

/**
 * Validate that a parsed JSON object is a valid binding file format.
 * Returns an error message if invalid, undefined if valid.
 */
const validateBindingFile = (
  obj: unknown,
  filePath: string
): string | undefined => {
  if (obj === null || typeof obj !== "object") {
    return `${filePath}: Expected object, got ${typeof obj}`;
  }

  const manifest = obj as Record<string, unknown>;

  // Check for tsbindgen format
  if ("namespace" in manifest && "types" in manifest) {
    if (typeof manifest.namespace !== "string") {
      return `${filePath}: 'namespace' must be a string`;
    }
    if (!Array.isArray(manifest.types)) {
      return `${filePath}: 'types' must be an array`;
    }
    return undefined; // Valid tsbindgen format
  }

  // Check for full manifest format
  if ("assembly" in manifest && "namespaces" in manifest) {
    if (typeof manifest.assembly !== "string") {
      return `${filePath}: 'assembly' must be a string`;
    }
    if (!Array.isArray(manifest.namespaces)) {
      return `${filePath}: 'namespaces' must be an array`;
    }
    return undefined; // Valid full format
  }

  // Check for simple format (global/module bindings)
  if ("bindings" in manifest) {
    if (typeof manifest.bindings !== "object" || manifest.bindings === null) {
      return `${filePath}: 'bindings' must be an object`;
    }
    return undefined; // Valid simple format
  }

  return `${filePath}: Unrecognized binding file format. Expected tsbindgen (namespace+types), full (assembly+namespaces), or simple (bindings) format.`;
};

/**
 * Registry of all loaded bindings
 * Supports simple (global/module) and hierarchical (namespace/type/member) formats
 */
export class BindingRegistry {
  private readonly loadedBindingFiles = new Set<string>();

  // Simple format: global/module bindings for identifiers like console, Math, fs
  private readonly simpleBindings = new Map<string, SimpleBindingDescriptor>();

  // Hierarchical format: namespace/type/member bindings
  private readonly namespaces = new Map<string, NamespaceBinding>();
  private readonly types = new Map<string, TypeBinding>(); // Flat lookup by TS name
  private readonly members = new Map<string, MemberBinding>(); // Flat lookup by "type.member"
  private readonly memberOverloads = new Map<string, MemberBinding[]>(); // Overload-aware lookup by "type.member"
  private readonly clrMemberOverloads = new Map<string, MemberBinding[]>(); // Overload-aware lookup by CLR target key
  private readonly tsbindgenExports = new Map<string, Map<string, TsbindgenExport>>();
  private readonly tsSupertypes = new Map<string, Set<string>>();

  /**
   * Extension method index for instance-style calls.
   *
   * Keyed by:
   * - declaring namespace key (CLR namespace with '.' replaced by '_', e.g. "System_Linq")
   * - receiver TS type name (e.g. "IEnumerable_1")
   * - method TS name (e.g. "where")
   *
   * Values are one or more candidates (overloads share the same target).
   */
  private readonly extensionMethods = new Map<
    string,
    Map<string, Map<string, MemberBinding[]>>
  >();

  private getExtensionMethodCandidates(
    namespaceKey: string,
    receiverTypeName: string,
    methodTsName: string
  ): readonly MemberBinding[] | undefined {
    return this.extensionMethods
      .get(namespaceKey)
      ?.get(receiverTypeName)
      ?.get(methodTsName);
  }

  private addSupertype(typeAlias: string, superAlias: string): void {
    if (!typeAlias || !superAlias) return;
    if (typeAlias === superAlias) return;

    const set = this.tsSupertypes.get(typeAlias) ?? new Set<string>();
    set.add(superAlias);
    this.tsSupertypes.set(typeAlias, set);
  }

  private getDirectSupertypes(typeAlias: string): readonly string[] {
    const set = this.tsSupertypes.get(typeAlias);
    if (!set || set.size === 0) return [];
    return Array.from(set).sort((a, b) => a.localeCompare(b));
  }

  /**
   * Resolve an extension method binding target by extension interface name.
   *
   * @param extensionInterfaceName - e.g. "__Ext_System_Linq_IEnumerable_1"
   * @param methodTsName - e.g. "where"
   */
  resolveExtensionMethod(
    extensionInterfaceName: string,
    methodTsName: string,
    callArgumentCount?: number
  ): MemberBinding | undefined {
    const parsed = this.parseExtensionInterfaceName(extensionInterfaceName);
    if (!parsed) return undefined;

    type ResolveResult =
      | { readonly kind: "none" }
      | { readonly kind: "ambiguous" }
      | { readonly kind: "resolved"; readonly binding: MemberBinding };

    const getParameterCount = (binding: MemberBinding): number | undefined => {
      if (typeof binding.parameterCount === "number") {
        return binding.parameterCount;
      }

      const sig = binding.signature;
      if (!sig) return undefined;
      const paramsMatch = sig.match(/\|\(([^)]*)\):/);
      const paramsStr = paramsMatch?.[1]?.trim();
      if (!paramsStr) return undefined;
      return splitSignatureTypeList(paramsStr).length;
    };

    const getModifiersKey = (binding: MemberBinding): string => {
      const mods = (binding.parameterModifiers ?? []) as readonly ParameterModifier[];
      if (!Array.isArray(mods) || mods.length === 0) return "";
      return [...mods]
        .slice()
        .sort((a, b) => a.index - b.index)
        .map((m) => `${m.index}:${m.modifier}`)
        .join(",");
    };

    const resolveForReceiver = (receiverTypeName: string): ResolveResult => {
      const candidates = this.getExtensionMethodCandidates(
        parsed.namespaceKey,
        receiverTypeName,
        methodTsName
      );
      if (!candidates || candidates.length === 0) return { kind: "none" };

      let filteredCandidates: readonly MemberBinding[] = candidates;
      if (typeof callArgumentCount === "number") {
        const desiredParamCount = callArgumentCount + 1;

        const exact = candidates.filter(
          (c) => getParameterCount(c) === desiredParamCount
        );

        if (exact.length > 0) {
          filteredCandidates = exact;
        } else {
          // Optional-parameter safety: if no exact arity match, choose the smallest
          // candidate arity that can still accept the provided arguments.
          const larger = candidates
            .map((c) => ({ c, count: getParameterCount(c) }))
            .filter(
              (x): x is { c: MemberBinding; count: number } =>
                typeof x.count === "number" && x.count > desiredParamCount
            );

          if (larger.length === 0) return { kind: "none" };

          const minCount = Math.min(...larger.map((x) => x.count));
          filteredCandidates = larger
            .filter((x) => x.count === minCount)
            .map((x) => x.c);
        }
      }

      // If multiple candidates map to different CLR targets, treat as unresolved (unsafe).
      const first = filteredCandidates[0];
      if (!first) return { kind: "none" };
      const firstTarget = `${first.binding.type}::${first.binding.member}`;
      const firstModsKey = getModifiersKey(first);
      for (const c of filteredCandidates) {
        const target = `${c.binding.type}::${c.binding.member}`;
        if (target !== firstTarget) {
          return { kind: "ambiguous" };
        }

        if (getModifiersKey(c) !== firstModsKey) {
          return { kind: "ambiguous" };
        }
      }

      return { kind: "resolved", binding: first };
    };

    // 1) Exact receiver match.
    const direct = resolveForReceiver(parsed.receiverTypeName);
    if (direct.kind === "resolved") return direct.binding;
    if (direct.kind === "ambiguous") return undefined;

    // 2) Airplane-grade fallback: CLR interface/base-type inheritance.
    // This allows instance-style calls to resolve when TS surface selects a method
    // declared on a derived type's extension bucket (e.g., IQueryable<T>.ToList)
    // but the CLR binding is declared on a base interface (e.g., IEnumerable<T>).
    //
    // Determinism rules:
    // - Prefer the closest base match (BFS).
    // - If multiple matches exist at the same depth with different CLR targets,
    //   treat as unresolved (unsafe).
    const visited = new Set<string>([parsed.receiverTypeName]);
    let frontier: readonly string[] = [parsed.receiverTypeName];

    for (let depth = 0; depth < 20; depth++) {
      const next: string[] = [];
      for (const t of frontier) {
        for (const sup of this.getDirectSupertypes(t)) {
          if (visited.has(sup)) continue;
          visited.add(sup);
          next.push(sup);
        }
      }

      if (next.length === 0) break;

      const resolvedAtDepth: MemberBinding[] = [];
      let sawAmbiguous = false;

      for (const sup of next) {
        const res = resolveForReceiver(sup);
        if (res.kind === "ambiguous") sawAmbiguous = true;
        if (res.kind === "resolved") resolvedAtDepth.push(res.binding);
      }

      if (resolvedAtDepth.length > 0 || sawAmbiguous) {
        // If any ambiguity exists at the closest depth, do not guess.
        if (sawAmbiguous) return undefined;
        const first = resolvedAtDepth[0];
        if (!first) return undefined;
        const target0 = `${first.binding.type}::${first.binding.member}`;
        const mods0 = getModifiersKey(first);
        for (const b of resolvedAtDepth) {
          const target = `${b.binding.type}::${b.binding.member}`;
          if (target !== target0) return undefined;
          if (getModifiersKey(b) !== mods0) return undefined;
        }
        return first;
      }

      frontier = next;
    }

    return undefined;
  }

  private parseExtensionInterfaceName(
    extensionInterfaceName: string
  ): { readonly namespaceKey: string; readonly receiverTypeName: string } | undefined {
    if (!extensionInterfaceName.startsWith("__Ext_")) return undefined;
    const rest = extensionInterfaceName.slice("__Ext_".length);

    // Find the longest namespaceKey prefix we have indexed.
    let bestNamespaceKey: string | undefined;
    for (const namespaceKey of this.extensionMethods.keys()) {
      if (rest.startsWith(`${namespaceKey}_`)) {
        if (!bestNamespaceKey || namespaceKey.length > bestNamespaceKey.length) {
          bestNamespaceKey = namespaceKey;
        }
      }
    }
    if (!bestNamespaceKey) return undefined;

    const receiverTypeName = rest.slice(bestNamespaceKey.length + 1);
    if (!receiverTypeName) return undefined;

    return { namespaceKey: bestNamespaceKey, receiverTypeName };
  }

  /**
   * Load a binding manifest file and add its bindings to the registry
   * Supports simple, full, and tsbindgen formats
   */
  addBindings(_filePath: string, manifest: BindingFile): void {
    // Airplane-grade: a given bindings file must be loaded exactly once per
    // ProgramContext. Some converters perform on-demand bindings.json loading
    // based on Binding-resolved MemberIds; without this guard, overload sets
    // can silently duplicate and become ambiguous.
    if (this.loadedBindingFiles.has(_filePath)) return;
    this.loadedBindingFiles.add(_filePath);

    const addMemberOverload = (key: string, member: MemberBinding): void => {
      const existing = this.memberOverloads.get(key) ?? [];
      existing.push(member);
      this.memberOverloads.set(key, existing);
    };

    const addClrMemberOverload = (member: MemberBinding): void => {
      if (member.kind !== "method") return;

      const clrTargetKey = makeClrMemberKey(
        member.binding.assembly,
        member.binding.type,
        member.binding.member
      );
      const existing = this.clrMemberOverloads.get(clrTargetKey) ?? [];
      existing.push(member);
      this.clrMemberOverloads.set(clrTargetKey, existing);
    };

    if (isFullBindingManifest(manifest)) {
      // Full format: hierarchical namespace/type/member structure
      // Index by alias (TS identifier) for quick lookup
      for (const ns of manifest.namespaces) {
        this.namespaces.set(ns.alias, ns);

        // Index types for quick lookup by TS alias
        for (const type of ns.types) {
          this.types.set(type.alias, type);

          // Index members for quick lookup (keyed by "typeAlias.memberAlias")
          for (const member of type.members) {
            const key = `${type.alias}.${member.alias}`;
            this.members.set(key, member);
            addMemberOverload(key, member);
            addClrMemberOverload(member);
          }
        }
      }
    } else if (isTsbindgenBindingFile(manifest)) {
      // tsbindgen format: convert to internal format
      for (const tsbType of manifest.types) {
        // Create members from methods, properties, and fields
        const members: MemberBinding[] = [];

        for (const method of tsbType.methods) {
          const memberBinding: MemberBinding = {
            kind: "method",
            name: method.clrName,
            // No naming policy: TS member names are the CLR names as authored.
            alias: method.clrName,
            signature: method.normalizedSignature,
            parameterCount: method.parameterCount,
            binding: {
              assembly: method.declaringAssemblyName,
              type: method.declaringClrType,
              // member = clrName (what C# emits, e.g., "Add")
              member: method.clrName,
            },
            // Include parameter modifiers for ref/out/in parameters
            parameterModifiers: method.parameterModifiers,
            isExtensionMethod: method.isExtensionMethod ?? false,
          };

          members.push(memberBinding);

          addClrMemberOverload(memberBinding);

          // Index extension methods by (declaring namespace, receiver type, method name).
          if (method.isExtensionMethod && method.normalizedSignature) {
            const receiverTypeName =
              extractExtensionReceiverType(method.normalizedSignature);
            const namespaceKey = extractNamespaceKey(method.declaringClrType);
            if (receiverTypeName && namespaceKey) {
              const nsMap =
                this.extensionMethods.get(namespaceKey) ??
                new Map<string, Map<string, MemberBinding[]>>();
              if (!this.extensionMethods.has(namespaceKey)) {
                this.extensionMethods.set(namespaceKey, nsMap);
              }

              const receiverMap =
                nsMap.get(receiverTypeName) ??
                new Map<string, MemberBinding[]>();
              if (!nsMap.has(receiverTypeName)) {
                nsMap.set(receiverTypeName, receiverMap);
              }

              const list = receiverMap.get(memberBinding.alias) ?? [];
              list.push(memberBinding);
              receiverMap.set(memberBinding.alias, list);
            }
          }
        }

        for (const prop of tsbType.properties) {
          members.push({
            kind: "property",
            name: prop.clrName,
            alias: prop.clrName,
            binding: {
              assembly: prop.declaringAssemblyName,
              type: prop.declaringClrType,
              member: prop.clrName,
            },
          });
        }

        for (const field of tsbType.fields) {
          // Fields are treated as properties for binding purposes
          members.push({
            kind: "property",
            name: field.clrName,
            alias: field.clrName,
            binding: {
              assembly: field.declaringAssemblyName,
              type: field.declaringClrType,
              member: field.clrName,
            },
          });
        }

        const tsAlias = tsbindgenClrTypeNameToTsTypeName(tsbType.clrName);

        // Record CLR inheritance relationships (base type + interfaces) so extension-method
        // binding lookup can follow the CLR graph deterministically.
        const baseAlias = tsbType.baseType?.clrName
          ? tsbindgenClrTypeNameToTsTypeName(tsbType.baseType.clrName)
          : undefined;
        if (baseAlias) this.addSupertype(tsAlias, baseAlias);

        for (const iface of tsbType.interfaces ?? []) {
          if (!iface?.clrName) continue;
          const ifaceAlias = tsbindgenClrTypeNameToTsTypeName(iface.clrName);
          this.addSupertype(tsAlias, ifaceAlias);
        }

        const kindFromBindings = (() => {
          switch (tsbType.kind) {
            case "Interface":
              return "interface" as const;
            case "Struct":
              return "struct" as const;
            case "Enum":
              return "enum" as const;
            case "Class":
            default:
              return "class" as const;
          }
        })();

        // Create TypeBinding - TS alias is derived deterministically from CLR name.
        const typeBinding: TypeBinding = {
          name: tsbType.clrName,
          alias: tsAlias,
          kind: kindFromBindings,
          members,
        };

        // Index the type by its TS name.
        this.types.set(typeBinding.alias, typeBinding);

        // Also index by simple name if ts alias has arity suffix (e.g., "List_1" -> also index as "List")
        // This is needed because TS exports both List_1 and List as aliases, and TS code uses List<T>
        // IMPORTANT: Only set if not already present - non-generic versions should take precedence
        // (e.g., Action should resolve to System.Action, not System.Action`9)
        const arityMatch = typeBinding.alias.match(/^(.+)_(\d+)$/);
        const simpleAlias = arityMatch ? arityMatch[1] : null;
        if (
          simpleAlias &&
          simpleAlias !== typeBinding.alias &&
          !this.types.has(simpleAlias)
        ) {
          this.types.set(simpleAlias, typeBinding);
        }

        // Index members for direct lookup.
        for (const member of members) {
          // Key by TS name (e.g., "List_1.Add")
          const tsKey = `${typeBinding.alias}.${member.alias}`;
          this.members.set(tsKey, member);
          addMemberOverload(tsKey, member);

          // Also key by simple alias if applicable (e.g., "List.Add")
          if (simpleAlias) {
            const simpleKey = `${simpleAlias}.${member.alias}`;
            this.members.set(simpleKey, member);
            addMemberOverload(simpleKey, member);
          }
        }
      }

      // Optional flattened named exports.
      // These are stable value exports for CLR namespace facade modules and are
      // resolved by Tsonic during import binding (so `import { x }` maps to
      // `global::<DeclaringType>.<member>` in C#).
      if (manifest.exports) {
        const nsExports =
          this.tsbindgenExports.get(manifest.namespace) ??
          new Map<string, TsbindgenExport>();

        for (const [exportName, exp] of Object.entries(manifest.exports)) {
          nsExports.set(exportName, exp);
        }

        this.tsbindgenExports.set(manifest.namespace, nsExports);
      }
    } else {
      // Simple format: global/module bindings
      for (const [name, descriptor] of Object.entries(manifest.bindings)) {
        this.simpleBindings.set(name, descriptor);
      }
    }
  }

  /**
   * Look up a simple global/module binding
   */
  getBinding(name: string): SimpleBindingDescriptor | undefined {
    return this.simpleBindings.get(name);
  }

  /**
   * Look up a namespace binding by TS alias
   */
  getNamespace(tsAlias: string): NamespaceBinding | undefined {
    return this.namespaces.get(tsAlias);
  }

  /**
   * Look up a type binding by TS alias
   */
  getType(tsAlias: string): TypeBinding | undefined {
    return this.types.get(tsAlias);
  }

  /**
   * Look up a member binding by TS type alias and member alias
   */
  getMember(typeAlias: string, memberAlias: string): MemberBinding | undefined {
    const key = `${typeAlias}.${memberAlias}`;
    const direct = this.members.get(key);
    if (direct) return direct;

    // tsbindgen encodes protected CLR members on a synthetic `${TypeName}$protected` class.
    // Those members are still declared on the real CLR type, so bindings must resolve
    // through the owning type alias.
    if (typeAlias.endsWith("$protected")) {
      const ownerAlias = typeAlias.slice(0, -"$protected".length);
      return this.members.get(`${ownerAlias}.${memberAlias}`);
    }

    return undefined;
  }

  /**
   * Look up all member bindings for a TS type alias + member alias.
   *
   * IMPORTANT: Methods can be overloaded, and overloads can differ in ref/out/in
   * modifiers (tsbindgen provides these via `parameterModifiers`). This accessor
   * preserves overload sets so the call converter can select the correct one.
   */
  getMemberOverloads(
    typeAlias: string,
    memberAlias: string
  ): readonly MemberBinding[] | undefined {
    const key = `${typeAlias}.${memberAlias}`;
    const direct = this.memberOverloads.get(key);
    if (direct && direct.length > 0) return direct;

    // See getMember(): map `${TypeName}$protected` to `${TypeName}` for CLR binding lookup.
    if (typeAlias.endsWith("$protected")) {
      const ownerAlias = typeAlias.slice(0, -"$protected".length);
      const ownerKey = `${ownerAlias}.${memberAlias}`;
      const owner = this.memberOverloads.get(ownerKey);
      if (owner && owner.length > 0) return owner;
    }

    return undefined;
  }

  /**
   * Look up all member bindings for a CLR member target.
   *
   * Keyed by declaring assembly, CLR type, and CLR member name.
   */
  getClrMemberOverloads(
    assembly: string,
    clrType: string,
    clrMember: string
  ): readonly MemberBinding[] | undefined {
    return this.clrMemberOverloads.get(makeClrMemberKey(assembly, clrType, clrMember));
  }

  /**
   * Look up a tsbindgen flattened named export by CLR namespace + export name.
   */
  getTsbindgenExport(
    namespace: string,
    exportName: string
  ): TsbindgenExport | undefined {
    return this.tsbindgenExports.get(namespace)?.get(exportName);
  }

  /**
   * Get all loaded simple bindings
   */
  getAllBindings(): readonly [string, SimpleBindingDescriptor][] {
    return Array.from(this.simpleBindings.entries());
  }

  /**
   * Get all loaded namespaces
   */
  getAllNamespaces(): readonly NamespaceBinding[] {
    return Array.from(this.namespaces.values());
  }

  /**
   * Get a copy of the types map for passing to the emitter.
   * Returns a new Map to ensure immutability - callers cannot modify the registry.
   */
  getTypesMap(): ReadonlyMap<string, TypeBinding> {
    return new Map(this.types);
  }

  /**
   * Clear all loaded bindings
   */
  clear(): void {
    this.loadedBindingFiles.clear();
    this.simpleBindings.clear();
    this.namespaces.clear();
    this.types.clear();
    this.members.clear();
    this.memberOverloads.clear();
    this.clrMemberOverloads.clear();
    this.extensionMethods.clear();
    this.tsbindgenExports.clear();
  }
}

const makeClrMemberKey = (
  assembly: string,
  clrType: string,
  clrMember: string
): string => `${assembly}:${clrType}::${clrMember}`;

/**
 * Extract CLR namespace key ('.' → '_') from a full CLR type name.
 * Example: "System.Linq.Enumerable" → "System_Linq"
 */
const extractNamespaceKey = (clrType: string): string | undefined => {
  const lastDot = clrType.lastIndexOf(".");
  if (lastDot <= 0) return undefined;
  return clrType.slice(0, lastDot).replace(/\./g, "_");
};

/**
 * Extract the extension receiver TS type name from a tsbindgen normalized signature.
 *
 * Format: "Name|(ParamTypes):ReturnType|static=true"
 * Example: "Where|(IEnumerable_1,Func_2):IEnumerable_1|static=true"
 *
 * Returns the first parameter type name (stripped of byref suffix and namespace prefix).
 */
const extractExtensionReceiverType = (
  normalizedSignature: string
): string | undefined => {
  const paramsMatch = normalizedSignature.match(/\|\(([^)]*)\):/);
  const paramsStr = paramsMatch?.[1]?.trim();
  if (!paramsStr) return undefined;

  const [first] = splitSignatureTypeList(paramsStr);
  if (!first) return undefined;

  let receiver = first.trim();
  if (receiver.endsWith("&")) receiver = receiver.slice(0, -1);
  if (receiver.endsWith("[]")) receiver = receiver.slice(0, -2);
  const lastDot = receiver.lastIndexOf(".");
  if (lastDot >= 0) receiver = receiver.slice(lastDot + 1);
  return receiver || undefined;
};

/**
 * Split a comma-delimited type list, respecting nested bracket depth.
 * tsbindgen signatures use CLR-style nested generic brackets in some contexts.
 */
const splitSignatureTypeList = (str: string): string[] => {
  const result: string[] = [];
  let depth = 0;
  let current = "";

  for (const char of str) {
    if (char === "[") {
      depth++;
      current += char;
    } else if (char === "]") {
      depth--;
      current += char;
    } else if (char === "," && depth === 0) {
      result.push(current.trim());
      current = "";
    } else {
      current += char;
    }
  }

  if (current.trim()) {
    result.push(current.trim());
  }

  return result;
};

/**
 * Recursively scan a directory for .d.ts files
 * Reuses the same helper as metadata loading
 */
const scanForDeclarationFiles = (dir: string): readonly string[] => {
  if (!fs.existsSync(dir)) {
    return [];
  }

  const results: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...scanForDeclarationFiles(fullPath));
    } else if (entry.name.endsWith(".d.ts")) {
      results.push(fullPath);
    }
  }

  return results;
};

/**
 * Load bindings from a package directory and recursively from its @tsonic/* dependencies.
 *
 * This supports the common "namespace facade" layout:
 * - `System.d.ts` (or `index.d.ts`) at the package root
 * - `System/bindings.json` (or `index/bindings.json`) next to the namespace's `internal/index.d.ts`
 *
 * Some packages may also provide a root-level `bindings.json` (simple/global bindings).
 */
const loadBindingsFromPackage = (
  registry: BindingRegistry,
  packageRoot: string,
  visited: Set<string>
): void => {
  // Avoid cycles
  const absoluteRoot = path.resolve(packageRoot);
  if (visited.has(absoluteRoot)) {
    return;
  }
  visited.add(absoluteRoot);

  // Skip if directory doesn't exist
  if (!fs.existsSync(absoluteRoot)) {
    return;
  }

  const rootEntries = fs.readdirSync(absoluteRoot, { withFileTypes: true });

  // Strategy 1: root-level bindings.json (simple/global bindings)
  const rootBindingsPath = path.join(absoluteRoot, "bindings.json");
  loadBindingsFromPath(registry, rootBindingsPath);

  // Strategy 2: Namespace/bindings.json for each Namespace.d.ts facade
  const facadeFiles = rootEntries
    .filter((e) => e.isFile() && e.name.endsWith(".d.ts"))
    .map((e) => e.name);

  for (const facadeFile of facadeFiles) {
    // e.g., "System.d.ts" → "System"
    const namespaceName = facadeFile.slice(0, -".d.ts".length);
    const namespaceDir = path.join(absoluteRoot, namespaceName);
    const bindingsPath = path.join(namespaceDir, "bindings.json");

    if (fs.existsSync(bindingsPath)) {
      loadBindingsFromPath(registry, bindingsPath);
    }
  }

  // Strategy 3: Recursively load bindings from @tsonic/* dependencies
  // This is crucial for packages like @tsonic/globals that depend on @tsonic/dotnet
  const packageJsonPath = path.join(absoluteRoot, "package.json");
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      const deps = packageJson.dependencies || {};

      for (const depName of Object.keys(deps)) {
        // Only follow @tsonic/* dependencies to load their bindings
        if (depName.startsWith("@tsonic/")) {
          // Find the dependency in node_modules
          // Try sibling node_modules first (hoisted), then nested
          const nodeModulesDir = path.dirname(path.dirname(absoluteRoot));
          const hoistedPath = path.join(nodeModulesDir, depName);
          const nestedPath = path.join(absoluteRoot, "node_modules", depName);

          if (fs.existsSync(hoistedPath)) {
            loadBindingsFromPackage(registry, hoistedPath, visited);
          } else if (fs.existsSync(nestedPath)) {
            loadBindingsFromPackage(registry, nestedPath, visited);
          }
        }
      }
    } catch {
      // Ignore JSON parse errors in package.json
    }
  }
};

/**
 * Load binding manifests from configured type roots.
 *
 * Conventions:
 * - Root-level `bindings.json` (simple/global bindings)
 * - `Namespace.d.ts` + `Namespace/bindings.json` (namespace facade)
 *
 * Also recursively loads bindings from @tsonic/* dependencies of typeRoot packages.
 */
export const loadBindings = (typeRoots: readonly string[]): BindingRegistry => {
  const registry = new BindingRegistry();
  const visited = new Set<string>();

  for (const typeRoot of typeRoots) {
    loadBindingsFromPackage(registry, typeRoot, visited);
  }

  return registry;
};

/**
 * Load bindings from a specific file path into an existing registry.
 * Validates the file format and logs a warning if invalid.
 */
export const loadBindingsFromPath = (
  registry: BindingRegistry,
  bindingsPath: string
): void => {
  try {
    if (fs.existsSync(bindingsPath)) {
      const content = fs.readFileSync(bindingsPath, "utf-8");
      const parsed = JSON.parse(content) as unknown;

      // Validate the parsed structure
      const validationError = validateBindingFile(parsed, bindingsPath);
      if (validationError) {
        console.warn(`Invalid bindings file: ${validationError}`);
        return;
      }

      registry.addBindings(bindingsPath, parsed as BindingFile);
    }
  } catch (err) {
    if (err instanceof SyntaxError) {
      console.warn(
        `Failed to parse bindings from ${bindingsPath}: Invalid JSON - ${err.message}`
      );
    } else {
      console.warn(`Failed to load bindings from ${bindingsPath}:`, err);
    }
  }
};

/**
 * Load all CLR bindings discovered by the resolver.
 * This should be called AFTER createProgram but BEFORE IR building
 * to ensure all bindings are available during IR construction.
 *
 * Note: The ClrBindingsResolver tracks discovered binding paths via caching,
 * so this loads bindings for any imports that were already resolved.
 */
export const loadAllDiscoveredBindings = (
  registry: BindingRegistry,
  discoveredPaths: ReadonlySet<string>
): void => {
  for (const bindingsPath of discoveredPaths) {
    loadBindingsFromPath(registry, bindingsPath);
  }
};
