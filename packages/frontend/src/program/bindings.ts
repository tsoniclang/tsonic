/**
 * Binding manifest loading - maps JS/TS names to CLR types/members
 * See spec/bindings.md for full manifest format
 */

import * as fs from "node:fs";
import * as path from "node:path";

/**
 * Member binding (method/property level)
 */
export type MemberBinding = {
  readonly kind: "method" | "property";
  readonly signature?: string; // Optional TS signature for diagnostics
  readonly name: string; // CLR member name (e.g., "SelectMany")
  readonly alias: string; // TS identifier (e.g., "selectMany")
  readonly binding: {
    readonly assembly: string;
    readonly type: string; // Full CLR type (e.g., "System.Linq.Enumerable")
    readonly member: string; // CLR member name
  };
};

/**
 * Type binding (class/interface/struct/enum level)
 */
export type TypeBinding = {
  readonly name: string; // CLR type name (e.g., "Enumerable")
  readonly alias: string; // TS identifier (e.g., "enumerable")
  readonly kind: "class" | "interface" | "struct" | "enum";
  readonly members: readonly MemberBinding[];
};

/**
 * Namespace binding
 */
export type NamespaceBinding = {
  readonly name: string; // CLR namespace (e.g., "System.Linq")
  readonly alias: string; // TS identifier (e.g., "systemLinq")
  readonly types: readonly TypeBinding[];
};

/**
 * Full binding manifest structure (new format from bindings.md)
 */
export type FullBindingManifest = {
  readonly assembly: string;
  readonly namespaces: readonly NamespaceBinding[];
};

/**
 * Simple binding entry (legacy format for backwards compatibility)
 * Maps simple global/module identifiers to CLR types
 */
export type SimpleBindingDescriptor = {
  readonly kind: "global" | "module";
  readonly assembly: string;
  readonly type: string;
  readonly csharpName?: string; // Optional: rename identifier in generated C#
};

/**
 * Legacy binding file structure (backwards compatible)
 */
export type LegacyBindingFile = {
  readonly bindings: Readonly<Record<string, SimpleBindingDescriptor>>;
};

/**
 * tsbindgen format - generated by tsbindgen tool
 * This is the format produced when generating bindings from .NET assemblies
 */
export type TsbindgenMethod = {
  readonly clrName: string;
  readonly tsEmitName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenProperty = {
  readonly clrName: string;
  readonly tsEmitName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenField = {
  readonly clrName: string;
  readonly tsEmitName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenType = {
  readonly clrName: string; // Full CLR type name (e.g., "System.Console")
  readonly tsEmitName: string; // TypeScript name (e.g., "Console")
  readonly assemblyName: string;
  readonly methods: readonly TsbindgenMethod[];
  readonly properties: readonly TsbindgenProperty[];
  readonly fields: readonly TsbindgenField[];
};

export type TsbindgenBindingFile = {
  readonly namespace: string;
  readonly types: readonly TsbindgenType[];
};

/**
 * Union type for all binding formats
 */
export type BindingFile =
  | FullBindingManifest
  | LegacyBindingFile
  | TsbindgenBindingFile;

/**
 * Type guard to check if a manifest is the full format
 */
const isFullBindingManifest = (
  manifest: BindingFile
): manifest is FullBindingManifest => {
  return "assembly" in manifest && "namespaces" in manifest;
};

/**
 * Type guard to check if a manifest is the tsbindgen format
 */
const isTsbindgenBindingFile = (
  manifest: BindingFile
): manifest is TsbindgenBindingFile => {
  return (
    "namespace" in manifest &&
    "types" in manifest &&
    !("namespaces" in manifest)
  );
};

/**
 * Validate that a parsed JSON object is a valid binding file format.
 * Returns an error message if invalid, undefined if valid.
 */
const validateBindingFile = (
  obj: unknown,
  filePath: string
): string | undefined => {
  if (obj === null || typeof obj !== "object") {
    return `${filePath}: Expected object, got ${typeof obj}`;
  }

  const manifest = obj as Record<string, unknown>;

  // Check for tsbindgen format
  if ("namespace" in manifest && "types" in manifest) {
    if (typeof manifest.namespace !== "string") {
      return `${filePath}: 'namespace' must be a string`;
    }
    if (!Array.isArray(manifest.types)) {
      return `${filePath}: 'types' must be an array`;
    }
    return undefined; // Valid tsbindgen format
  }

  // Check for full manifest format
  if ("assembly" in manifest && "namespaces" in manifest) {
    if (typeof manifest.assembly !== "string") {
      return `${filePath}: 'assembly' must be a string`;
    }
    if (!Array.isArray(manifest.namespaces)) {
      return `${filePath}: 'namespaces' must be an array`;
    }
    return undefined; // Valid full format
  }

  // Check for legacy format
  if ("bindings" in manifest) {
    if (typeof manifest.bindings !== "object" || manifest.bindings === null) {
      return `${filePath}: 'bindings' must be an object`;
    }
    return undefined; // Valid legacy format
  }

  return `${filePath}: Unrecognized binding file format. Expected tsbindgen (namespace+types), full (assembly+namespaces), or legacy (bindings) format.`;
};

/**
 * Registry of all loaded bindings
 * Supports both legacy (simple global/module) and new (hierarchical namespace/type/member) formats
 */
export class BindingRegistry {
  // Legacy format: simple global/module bindings
  private readonly simpleBindings = new Map<string, SimpleBindingDescriptor>();

  // New format: hierarchical bindings
  private readonly namespaces = new Map<string, NamespaceBinding>();
  private readonly types = new Map<string, TypeBinding>(); // Flat lookup by TS name
  private readonly members = new Map<string, MemberBinding>(); // Flat lookup by "type.member"

  /**
   * Load a binding manifest file and add its bindings to the registry
   * Supports legacy, full, and tsbindgen formats
   */
  addBindings(_filePath: string, manifest: BindingFile): void {
    if (isFullBindingManifest(manifest)) {
      // Full format: hierarchical namespace/type/member structure
      // Index by alias (TS identifier) for quick lookup
      for (const ns of manifest.namespaces) {
        this.namespaces.set(ns.alias, ns);

        // Index types for quick lookup by TS alias
        for (const type of ns.types) {
          this.types.set(type.alias, type);

          // Index members for quick lookup (keyed by "typeAlias.memberAlias")
          for (const member of type.members) {
            const key = `${type.alias}.${member.alias}`;
            this.members.set(key, member);
          }
        }
      }
    } else if (isTsbindgenBindingFile(manifest)) {
      // tsbindgen format: convert to internal format
      // Key by tsEmitName (what TS code writes), emit clrName (what C# needs)
      // Also key by clrName for packages that expose PascalCase in .d.ts
      for (const tsbType of manifest.types) {
        // Create members from methods, properties, and fields
        const members: MemberBinding[] = [];

        for (const method of tsbType.methods) {
          members.push({
            kind: "method",
            name: method.clrName,
            // alias = tsEmitName (what TS code uses, e.g., "add")
            alias: method.tsEmitName,
            binding: {
              assembly: method.declaringAssemblyName,
              type: method.declaringClrType,
              // member = clrName (what C# emits, e.g., "Add")
              member: method.clrName,
            },
          });
        }

        for (const prop of tsbType.properties) {
          members.push({
            kind: "property",
            name: prop.clrName,
            alias: prop.tsEmitName,
            binding: {
              assembly: prop.declaringAssemblyName,
              type: prop.declaringClrType,
              member: prop.clrName,
            },
          });
        }

        for (const field of tsbType.fields) {
          // Fields are treated as properties for binding purposes
          members.push({
            kind: "property",
            name: field.clrName,
            alias: field.tsEmitName,
            binding: {
              assembly: field.declaringAssemblyName,
              type: field.declaringClrType,
              member: field.clrName,
            },
          });
        }

        // Create TypeBinding - use tsEmitName as the TS alias (e.g., "Console")
        const typeBinding: TypeBinding = {
          name: tsbType.clrName,
          alias: tsbType.tsEmitName,
          kind: "class", // Default to class; could be refined with more metadata
          members,
        };

        // Index the type by its TS name (tsEmitName)
        this.types.set(typeBinding.alias, typeBinding);

        // Also index by simple name if tsEmitName has arity suffix (e.g., "List_1" -> also index as "List")
        // This is needed because TS exports both List_1 and List as aliases, and TS code uses List<T>
        // IMPORTANT: Only set if not already present - non-generic versions should take precedence
        // (e.g., Action should resolve to System.Action, not System.Action`9)
        const arityMatch = typeBinding.alias.match(/^(.+)_(\d+)$/);
        const simpleAlias = arityMatch ? arityMatch[1] : null;
        if (
          simpleAlias &&
          simpleAlias !== typeBinding.alias &&
          !this.types.has(simpleAlias)
        ) {
          this.types.set(simpleAlias, typeBinding);
        }

        // Index members for direct lookup by BOTH tsEmitName and clrName
        // This allows TS code to use either naming convention
        for (const member of members) {
          // Key by tsEmitName (e.g., "List_1.add")
          const tsKey = `${typeBinding.alias}.${member.alias}`;
          this.members.set(tsKey, member);

          // Also key by simple alias if applicable (e.g., "List.add")
          if (simpleAlias) {
            const simpleKey = `${simpleAlias}.${member.alias}`;
            this.members.set(simpleKey, member);
          }

          // Also key by clrName if different (e.g., "List_1.Add" and "List.Add")
          if (member.alias !== member.name) {
            const clrKey = `${typeBinding.alias}.${member.name}`;
            this.members.set(clrKey, member);
            if (simpleAlias) {
              const simpleClrKey = `${simpleAlias}.${member.name}`;
              this.members.set(simpleClrKey, member);
            }
          }
        }
      }
    } else {
      // Legacy format: simple global/module bindings
      for (const [name, descriptor] of Object.entries(manifest.bindings)) {
        this.simpleBindings.set(name, descriptor);
      }
    }
  }

  /**
   * Look up a simple global/module binding (legacy format)
   */
  getBinding(name: string): SimpleBindingDescriptor | undefined {
    return this.simpleBindings.get(name);
  }

  /**
   * Look up a namespace binding by TS alias
   */
  getNamespace(tsAlias: string): NamespaceBinding | undefined {
    return this.namespaces.get(tsAlias);
  }

  /**
   * Look up a type binding by TS alias
   */
  getType(tsAlias: string): TypeBinding | undefined {
    return this.types.get(tsAlias);
  }

  /**
   * Look up a member binding by TS type alias and member alias
   */
  getMember(typeAlias: string, memberAlias: string): MemberBinding | undefined {
    const key = `${typeAlias}.${memberAlias}`;
    return this.members.get(key);
  }

  /**
   * Get all loaded simple bindings (legacy)
   */
  getAllBindings(): readonly [string, SimpleBindingDescriptor][] {
    return Array.from(this.simpleBindings.entries());
  }

  /**
   * Get all loaded namespaces
   */
  getAllNamespaces(): readonly NamespaceBinding[] {
    return Array.from(this.namespaces.values());
  }

  /**
   * Get a copy of the types map for passing to the emitter.
   * Returns a new Map to ensure immutability - callers cannot modify the registry.
   */
  getTypesMap(): ReadonlyMap<string, TypeBinding> {
    return new Map(this.types);
  }

  /**
   * Clear all loaded bindings
   */
  clear(): void {
    this.simpleBindings.clear();
    this.namespaces.clear();
    this.types.clear();
    this.members.clear();
  }
}

/**
 * Recursively scan a directory for .d.ts files
 * Reuses the same helper as metadata loading
 */
const scanForDeclarationFiles = (dir: string): readonly string[] => {
  if (!fs.existsSync(dir)) {
    return [];
  }

  const results: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...scanForDeclarationFiles(fullPath));
    } else if (entry.name.endsWith(".d.ts")) {
      results.push(fullPath);
    }
  }

  return results;
};

/**
 * Load binding manifests from configured type roots
 * Looks for *.bindings.json files alongside .d.ts files OR directly in typeRoot
 */
export const loadBindings = (typeRoots: readonly string[]): BindingRegistry => {
  const registry = new BindingRegistry();

  for (const typeRoot of typeRoots) {
    const absoluteRoot = path.resolve(typeRoot);

    // Skip if directory doesn't exist
    if (!fs.existsSync(absoluteRoot)) {
      continue;
    }

    // Strategy 1: Look for manifest in the typeRoot itself
    const rootManifests = fs
      .readdirSync(absoluteRoot)
      .filter((f) => f.endsWith(".bindings.json"))
      .map((f) => path.join(absoluteRoot, f));

    for (const manifestPath of rootManifests) {
      loadBindingsFromPath(registry, manifestPath);
    }

    // Strategy 2: Look for *.bindings.json next to each .d.ts file
    const declFiles = scanForDeclarationFiles(absoluteRoot);
    for (const declPath of declFiles) {
      const manifestPath = declPath.replace(/\.d\.ts$/, ".bindings.json");
      loadBindingsFromPath(registry, manifestPath);

      // Strategy 3: Look for bindings.json in same directory as index.d.ts
      // This supports @tsonic/dotnet package structure where bindings.json
      // lives alongside index.d.ts in each namespace directory
      if (path.basename(declPath) === "index.d.ts") {
        const dirBindings = path.join(path.dirname(declPath), "bindings.json");
        loadBindingsFromPath(registry, dirBindings);
      }
    }
  }

  return registry;
};

/**
 * Load bindings from a specific file path into an existing registry.
 * Validates the file format and logs a warning if invalid.
 */
export const loadBindingsFromPath = (
  registry: BindingRegistry,
  bindingsPath: string
): void => {
  try {
    if (fs.existsSync(bindingsPath)) {
      const content = fs.readFileSync(bindingsPath, "utf-8");
      const parsed = JSON.parse(content) as unknown;

      // Validate the parsed structure
      const validationError = validateBindingFile(parsed, bindingsPath);
      if (validationError) {
        console.warn(`Invalid bindings file: ${validationError}`);
        return;
      }

      registry.addBindings(bindingsPath, parsed as BindingFile);
    }
  } catch (err) {
    if (err instanceof SyntaxError) {
      console.warn(
        `Failed to parse bindings from ${bindingsPath}: Invalid JSON - ${err.message}`
      );
    } else {
      console.warn(`Failed to load bindings from ${bindingsPath}:`, err);
    }
  }
};

/**
 * Load all CLR bindings discovered by the resolver.
 * This should be called AFTER createProgram but BEFORE IR building
 * to ensure all bindings are available during IR construction.
 *
 * Note: The ClrBindingsResolver tracks discovered binding paths via caching,
 * so this loads bindings for any imports that were already resolved.
 */
export const loadAllDiscoveredBindings = (
  registry: BindingRegistry,
  discoveredPaths: ReadonlySet<string>
): void => {
  for (const bindingsPath of discoveredPaths) {
    loadBindingsFromPath(registry, bindingsPath);
  }
};
