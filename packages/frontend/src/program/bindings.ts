/**
 * Binding manifest loading - maps JS/TS names to CLR types/members
 * See spec/bindings.md for full manifest format
 */

import * as fs from "node:fs";
import * as path from "node:path";

/**
 * Parameter modifier for ref/out/in parameters
 * Matches the format from tsbindgen: { index: number, modifier: "ref" | "out" | "in" }
 */
export type ParameterModifier = {
  readonly index: number;
  readonly modifier: "ref" | "out" | "in";
};

/**
 * Member binding (method/property level)
 */
export type MemberBinding = {
  readonly kind: "method" | "property";
  readonly signature?: string; // Optional TS signature for diagnostics
  /** Total CLR parameter count (includes extension receiver for extension methods). */
  readonly parameterCount?: number;
  readonly name: string; // CLR member name (e.g., "SelectMany")
  readonly alias: string; // TS identifier (e.g., "selectMany")
  readonly binding: {
    readonly assembly: string;
    readonly type: string; // Full CLR type (e.g., "System.Linq.Enumerable")
    readonly member: string; // CLR member name
  };
  // Parameter modifiers for ref/out/in parameters (from tsbindgen)
  readonly parameterModifiers?: readonly ParameterModifier[];
  // Whether this member is an extension method (tsbindgen metadata).
  // Used by the emitter to lower instance-style calls to explicit static calls.
  readonly isExtensionMethod?: boolean;
};

/**
 * Type binding (class/interface/struct/enum level)
 */
export type TypeBinding = {
  readonly name: string; // CLR type name (e.g., "Enumerable")
  readonly alias: string; // TS identifier (e.g., "enumerable")
  readonly kind: "class" | "interface" | "struct" | "enum";
  readonly members: readonly MemberBinding[];
};

/**
 * Namespace binding
 */
export type NamespaceBinding = {
  readonly name: string; // CLR namespace (e.g., "System.Linq")
  readonly alias: string; // TS identifier (e.g., "systemLinq")
  readonly types: readonly TypeBinding[];
};

/**
 * Full binding manifest structure (new format from bindings.md)
 */
export type FullBindingManifest = {
  readonly assembly: string;
  readonly namespaces: readonly NamespaceBinding[];
};

/**
 * Simple binding entry for global/module identifiers
 * Maps identifiers like `console`, `Math`, `fs` to CLR types
 */
export type SimpleBindingDescriptor = {
  readonly kind: "global" | "module";
  readonly assembly: string;
  readonly type: string;
  readonly csharpName?: string; // Optional: rename identifier in generated C#
};

/**
 * Simple binding file structure for global/module bindings
 */
export type SimpleBindingFile = {
  readonly bindings: Readonly<Record<string, SimpleBindingDescriptor>>;
};

/**
 * tsbindgen format - generated by tsbindgen tool
 * This is the format produced when generating bindings from .NET assemblies
 */
export type TsbindgenMethod = {
  readonly clrName: string;
  readonly tsEmitName: string;
  /** Normalized signature string (tsbindgen metadata, used for extension receiver inference) */
  readonly normalizedSignature?: string;
  /** Total parameter count in CLR signature (includes extension receiver) */
  readonly parameterCount?: number;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
  // Parameter modifiers for ref/out/in parameters
  readonly parameterModifiers?: readonly ParameterModifier[];
  readonly isExtensionMethod?: boolean;
};

export type TsbindgenProperty = {
  readonly clrName: string;
  readonly tsEmitName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenField = {
  readonly clrName: string;
  readonly tsEmitName: string;
  readonly declaringClrType: string;
  readonly declaringAssemblyName: string;
};

export type TsbindgenType = {
  readonly clrName: string; // Full CLR type name (e.g., "System.Console")
  readonly tsEmitName: string; // TypeScript name (e.g., "Console")
  readonly assemblyName: string;
  readonly methods: readonly TsbindgenMethod[];
  readonly properties: readonly TsbindgenProperty[];
  readonly fields: readonly TsbindgenField[];
};

export type TsbindgenBindingFile = {
  readonly namespace: string;
  readonly types: readonly TsbindgenType[];
};

/**
 * Union type for all binding formats
 */
export type BindingFile =
  | FullBindingManifest
  | SimpleBindingFile
  | TsbindgenBindingFile;

/**
 * Type guard to check if a manifest is the full format
 */
const isFullBindingManifest = (
  manifest: BindingFile
): manifest is FullBindingManifest => {
  return "assembly" in manifest && "namespaces" in manifest;
};

/**
 * Type guard to check if a manifest is the tsbindgen format
 */
const isTsbindgenBindingFile = (
  manifest: BindingFile
): manifest is TsbindgenBindingFile => {
  return (
    "namespace" in manifest &&
    "types" in manifest &&
    !("namespaces" in manifest)
  );
};

/**
 * Validate that a parsed JSON object is a valid binding file format.
 * Returns an error message if invalid, undefined if valid.
 */
const validateBindingFile = (
  obj: unknown,
  filePath: string
): string | undefined => {
  if (obj === null || typeof obj !== "object") {
    return `${filePath}: Expected object, got ${typeof obj}`;
  }

  const manifest = obj as Record<string, unknown>;

  // Check for tsbindgen format
  if ("namespace" in manifest && "types" in manifest) {
    if (typeof manifest.namespace !== "string") {
      return `${filePath}: 'namespace' must be a string`;
    }
    if (!Array.isArray(manifest.types)) {
      return `${filePath}: 'types' must be an array`;
    }
    return undefined; // Valid tsbindgen format
  }

  // Check for full manifest format
  if ("assembly" in manifest && "namespaces" in manifest) {
    if (typeof manifest.assembly !== "string") {
      return `${filePath}: 'assembly' must be a string`;
    }
    if (!Array.isArray(manifest.namespaces)) {
      return `${filePath}: 'namespaces' must be an array`;
    }
    return undefined; // Valid full format
  }

  // Check for simple format (global/module bindings)
  if ("bindings" in manifest) {
    if (typeof manifest.bindings !== "object" || manifest.bindings === null) {
      return `${filePath}: 'bindings' must be an object`;
    }
    return undefined; // Valid simple format
  }

  return `${filePath}: Unrecognized binding file format. Expected tsbindgen (namespace+types), full (assembly+namespaces), or simple (bindings) format.`;
};

/**
 * Registry of all loaded bindings
 * Supports simple (global/module) and hierarchical (namespace/type/member) formats
 */
export class BindingRegistry {
  // Simple format: global/module bindings for identifiers like console, Math, fs
  private readonly simpleBindings = new Map<string, SimpleBindingDescriptor>();

  // Hierarchical format: namespace/type/member bindings
  private readonly namespaces = new Map<string, NamespaceBinding>();
  private readonly types = new Map<string, TypeBinding>(); // Flat lookup by TS name
  private readonly members = new Map<string, MemberBinding>(); // Flat lookup by "type.member"

  /**
   * Extension method index for instance-style calls.
   *
   * Keyed by:
   * - declaring namespace key (CLR namespace with '.' replaced by '_', e.g. "System_Linq")
   * - receiver TS type name (e.g. "IEnumerable_1")
   * - method TS name (e.g. "where")
   *
   * Values are one or more candidates (overloads share the same target).
   */
  private readonly extensionMethods = new Map<
    string,
    Map<string, Map<string, MemberBinding[]>>
  >();

  private getExtensionMethodCandidates(
    namespaceKey: string,
    receiverTypeName: string,
    methodTsName: string
  ): readonly MemberBinding[] | undefined {
    return this.extensionMethods
      .get(namespaceKey)
      ?.get(receiverTypeName)
      ?.get(methodTsName);
  }

  /**
   * Resolve an extension method binding target by extension interface name.
   *
   * @param extensionInterfaceName - e.g. "__Ext_System_Linq_IEnumerable_1"
   * @param methodTsName - e.g. "where"
   */
  resolveExtensionMethod(
    extensionInterfaceName: string,
    methodTsName: string,
    callArgumentCount?: number
  ): MemberBinding | undefined {
    const parsed = this.parseExtensionInterfaceName(extensionInterfaceName);
    if (!parsed) return undefined;

    const candidates = this.getExtensionMethodCandidates(
      parsed.namespaceKey,
      parsed.receiverTypeName,
      methodTsName
    );
    if (!candidates || candidates.length === 0) return undefined;

    const getParameterCount = (binding: MemberBinding): number | undefined => {
      if (typeof binding.parameterCount === "number") {
        return binding.parameterCount;
      }

      const sig = binding.signature;
      if (!sig) return undefined;
      const paramsMatch = sig.match(/\|\(([^)]*)\):/);
      const paramsStr = paramsMatch?.[1]?.trim();
      if (!paramsStr) return undefined;
      return splitSignatureTypeList(paramsStr).length;
    };

    const getModifiersKey = (
      binding: MemberBinding
    ): string => {
      const mods = (binding.parameterModifiers ?? []) as readonly ParameterModifier[];
      if (!Array.isArray(mods) || mods.length === 0) return "";
      return [...mods]
        .slice()
        .sort((a, b) => a.index - b.index)
        .map((m) => `${m.index}:${m.modifier}`)
        .join(",");
    };

    let filteredCandidates: readonly MemberBinding[] = candidates;
    if (typeof callArgumentCount === "number") {
      const desiredParamCount = callArgumentCount + 1;

      const exact = candidates.filter(
        (c) => getParameterCount(c) === desiredParamCount
      );

      if (exact.length > 0) {
        filteredCandidates = exact;
      } else {
        // Optional-parameter safety: if no exact arity match, choose the smallest
        // candidate arity that can still accept the provided arguments.
        const larger = candidates
          .map((c) => ({ c, count: getParameterCount(c) }))
          .filter(
            (x): x is { c: MemberBinding; count: number } =>
              typeof x.count === "number" && x.count > desiredParamCount
          );

        if (larger.length === 0) return undefined;

        const minCount = Math.min(...larger.map((x) => x.count));
        filteredCandidates = larger
          .filter((x) => x.count === minCount)
          .map((x) => x.c);
      }
    }

    // If multiple candidates map to different CLR targets, treat as unresolved (unsafe).
    const first = filteredCandidates[0];
    if (!first) return undefined;
    const firstTarget = `${first.binding.type}::${first.binding.member}`;
    const firstModsKey = getModifiersKey(first);
    for (const c of filteredCandidates) {
      const target = `${c.binding.type}::${c.binding.member}`;
      if (target !== firstTarget) {
        return undefined;
      }

      if (getModifiersKey(c) !== firstModsKey) {
        return undefined;
      }
    }

    return first;
  }

  private parseExtensionInterfaceName(
    extensionInterfaceName: string
  ): { readonly namespaceKey: string; readonly receiverTypeName: string } | undefined {
    if (!extensionInterfaceName.startsWith("__Ext_")) return undefined;
    const rest = extensionInterfaceName.slice("__Ext_".length);

    // Find the longest namespaceKey prefix we have indexed.
    let bestNamespaceKey: string | undefined;
    for (const namespaceKey of this.extensionMethods.keys()) {
      if (rest.startsWith(`${namespaceKey}_`)) {
        if (!bestNamespaceKey || namespaceKey.length > bestNamespaceKey.length) {
          bestNamespaceKey = namespaceKey;
        }
      }
    }
    if (!bestNamespaceKey) return undefined;

    const receiverTypeName = rest.slice(bestNamespaceKey.length + 1);
    if (!receiverTypeName) return undefined;

    return { namespaceKey: bestNamespaceKey, receiverTypeName };
  }

  /**
   * Load a binding manifest file and add its bindings to the registry
   * Supports simple, full, and tsbindgen formats
   */
  addBindings(_filePath: string, manifest: BindingFile): void {
    if (isFullBindingManifest(manifest)) {
      // Full format: hierarchical namespace/type/member structure
      // Index by alias (TS identifier) for quick lookup
      for (const ns of manifest.namespaces) {
        this.namespaces.set(ns.alias, ns);

        // Index types for quick lookup by TS alias
        for (const type of ns.types) {
          this.types.set(type.alias, type);

          // Index members for quick lookup (keyed by "typeAlias.memberAlias")
          for (const member of type.members) {
            const key = `${type.alias}.${member.alias}`;
            this.members.set(key, member);
          }
        }
      }
    } else if (isTsbindgenBindingFile(manifest)) {
      // tsbindgen format: convert to internal format
      // Key by tsEmitName (what TS code writes), emit clrName (what C# needs)
      // Also key by clrName for packages that expose PascalCase in .d.ts
      for (const tsbType of manifest.types) {
        // Create members from methods, properties, and fields
        const members: MemberBinding[] = [];

        for (const method of tsbType.methods) {
          const memberBinding: MemberBinding = {
            kind: "method",
            name: method.clrName,
            // alias = tsEmitName (what TS code uses, e.g., "add")
            alias: method.tsEmitName,
            signature: method.normalizedSignature,
            parameterCount: method.parameterCount,
            binding: {
              assembly: method.declaringAssemblyName,
              type: method.declaringClrType,
              // member = clrName (what C# emits, e.g., "Add")
              member: method.clrName,
            },
            // Include parameter modifiers for ref/out/in parameters
            parameterModifiers: method.parameterModifiers,
            isExtensionMethod: method.isExtensionMethod ?? false,
          };

          members.push(memberBinding);

          // Index extension methods by (declaring namespace, receiver type, method name).
          if (method.isExtensionMethod && method.normalizedSignature) {
            const receiverTypeName =
              extractExtensionReceiverType(method.normalizedSignature);
            const namespaceKey = extractNamespaceKey(method.declaringClrType);
            if (receiverTypeName && namespaceKey) {
              const nsMap =
                this.extensionMethods.get(namespaceKey) ??
                new Map<string, Map<string, MemberBinding[]>>();
              if (!this.extensionMethods.has(namespaceKey)) {
                this.extensionMethods.set(namespaceKey, nsMap);
              }

              const receiverMap =
                nsMap.get(receiverTypeName) ??
                new Map<string, MemberBinding[]>();
              if (!nsMap.has(receiverTypeName)) {
                nsMap.set(receiverTypeName, receiverMap);
              }

              const list = receiverMap.get(memberBinding.alias) ?? [];
              list.push(memberBinding);
              receiverMap.set(memberBinding.alias, list);
            }
          }
        }

        for (const prop of tsbType.properties) {
          members.push({
            kind: "property",
            name: prop.clrName,
            alias: prop.tsEmitName,
            binding: {
              assembly: prop.declaringAssemblyName,
              type: prop.declaringClrType,
              member: prop.clrName,
            },
          });
        }

        for (const field of tsbType.fields) {
          // Fields are treated as properties for binding purposes
          members.push({
            kind: "property",
            name: field.clrName,
            alias: field.tsEmitName,
            binding: {
              assembly: field.declaringAssemblyName,
              type: field.declaringClrType,
              member: field.clrName,
            },
          });
        }

        // Create TypeBinding - use tsEmitName as the TS alias (e.g., "Console")
        const typeBinding: TypeBinding = {
          name: tsbType.clrName,
          alias: tsbType.tsEmitName,
          kind: "class", // Default to class; could be refined with more metadata
          members,
        };

        // Index the type by its TS name (tsEmitName)
        this.types.set(typeBinding.alias, typeBinding);

        // Also index by simple name if tsEmitName has arity suffix (e.g., "List_1" -> also index as "List")
        // This is needed because TS exports both List_1 and List as aliases, and TS code uses List<T>
        // IMPORTANT: Only set if not already present - non-generic versions should take precedence
        // (e.g., Action should resolve to System.Action, not System.Action`9)
        const arityMatch = typeBinding.alias.match(/^(.+)_(\d+)$/);
        const simpleAlias = arityMatch ? arityMatch[1] : null;
        if (
          simpleAlias &&
          simpleAlias !== typeBinding.alias &&
          !this.types.has(simpleAlias)
        ) {
          this.types.set(simpleAlias, typeBinding);
        }

        // Index members for direct lookup by BOTH tsEmitName and clrName
        // This allows TS code to use either naming convention
        for (const member of members) {
          // Key by tsEmitName (e.g., "List_1.add")
          const tsKey = `${typeBinding.alias}.${member.alias}`;
          this.members.set(tsKey, member);

          // Also key by simple alias if applicable (e.g., "List.add")
          if (simpleAlias) {
            const simpleKey = `${simpleAlias}.${member.alias}`;
            this.members.set(simpleKey, member);
          }

          // Also key by clrName if different (e.g., "List_1.Add" and "List.Add")
          if (member.alias !== member.name) {
            const clrKey = `${typeBinding.alias}.${member.name}`;
            this.members.set(clrKey, member);
            if (simpleAlias) {
              const simpleClrKey = `${simpleAlias}.${member.name}`;
              this.members.set(simpleClrKey, member);
            }
          }
        }
      }
    } else {
      // Simple format: global/module bindings
      for (const [name, descriptor] of Object.entries(manifest.bindings)) {
        this.simpleBindings.set(name, descriptor);
      }
    }
  }

  /**
   * Look up a simple global/module binding
   */
  getBinding(name: string): SimpleBindingDescriptor | undefined {
    return this.simpleBindings.get(name);
  }

  /**
   * Look up a namespace binding by TS alias
   */
  getNamespace(tsAlias: string): NamespaceBinding | undefined {
    return this.namespaces.get(tsAlias);
  }

  /**
   * Look up a type binding by TS alias
   */
  getType(tsAlias: string): TypeBinding | undefined {
    return this.types.get(tsAlias);
  }

  /**
   * Look up a member binding by TS type alias and member alias
   */
  getMember(typeAlias: string, memberAlias: string): MemberBinding | undefined {
    const key = `${typeAlias}.${memberAlias}`;
    return this.members.get(key);
  }

  /**
   * Get all loaded simple bindings
   */
  getAllBindings(): readonly [string, SimpleBindingDescriptor][] {
    return Array.from(this.simpleBindings.entries());
  }

  /**
   * Get all loaded namespaces
   */
  getAllNamespaces(): readonly NamespaceBinding[] {
    return Array.from(this.namespaces.values());
  }

  /**
   * Get a copy of the types map for passing to the emitter.
   * Returns a new Map to ensure immutability - callers cannot modify the registry.
   */
  getTypesMap(): ReadonlyMap<string, TypeBinding> {
    return new Map(this.types);
  }

  /**
   * Clear all loaded bindings
   */
  clear(): void {
    this.simpleBindings.clear();
    this.namespaces.clear();
    this.types.clear();
    this.members.clear();
    this.extensionMethods.clear();
  }
}

/**
 * Extract CLR namespace key ('.' → '_') from a full CLR type name.
 * Example: "System.Linq.Enumerable" → "System_Linq"
 */
const extractNamespaceKey = (clrType: string): string | undefined => {
  const lastDot = clrType.lastIndexOf(".");
  if (lastDot <= 0) return undefined;
  return clrType.slice(0, lastDot).replace(/\./g, "_");
};

/**
 * Extract the extension receiver TS type name from a tsbindgen normalized signature.
 *
 * Format: "Name|(ParamTypes):ReturnType|static=true"
 * Example: "Where|(IEnumerable_1,Func_2):IEnumerable_1|static=true"
 *
 * Returns the first parameter type name (stripped of byref suffix and namespace prefix).
 */
const extractExtensionReceiverType = (
  normalizedSignature: string
): string | undefined => {
  const paramsMatch = normalizedSignature.match(/\|\(([^)]*)\):/);
  const paramsStr = paramsMatch?.[1]?.trim();
  if (!paramsStr) return undefined;

  const [first] = splitSignatureTypeList(paramsStr);
  if (!first) return undefined;

  let receiver = first.trim();
  if (receiver.endsWith("&")) receiver = receiver.slice(0, -1);
  if (receiver.endsWith("[]")) receiver = receiver.slice(0, -2);
  const lastDot = receiver.lastIndexOf(".");
  if (lastDot >= 0) receiver = receiver.slice(lastDot + 1);
  return receiver || undefined;
};

/**
 * Split a comma-delimited type list, respecting nested bracket depth.
 * tsbindgen signatures use CLR-style nested generic brackets in some contexts.
 */
const splitSignatureTypeList = (str: string): string[] => {
  const result: string[] = [];
  let depth = 0;
  let current = "";

  for (const char of str) {
    if (char === "[") {
      depth++;
      current += char;
    } else if (char === "]") {
      depth--;
      current += char;
    } else if (char === "," && depth === 0) {
      result.push(current.trim());
      current = "";
    } else {
      current += char;
    }
  }

  if (current.trim()) {
    result.push(current.trim());
  }

  return result;
};

/**
 * Recursively scan a directory for .d.ts files
 * Reuses the same helper as metadata loading
 */
const scanForDeclarationFiles = (dir: string): readonly string[] => {
  if (!fs.existsSync(dir)) {
    return [];
  }

  const results: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...scanForDeclarationFiles(fullPath));
    } else if (entry.name.endsWith(".d.ts")) {
      results.push(fullPath);
    }
  }

  return results;
};

/**
 * Load bindings from a package directory and recursively from its @tsonic/* dependencies.
 * This ensures that when @tsonic/globals depends on @tsonic/dotnet, the bindings from
 * @tsonic/dotnet are also loaded.
 *
 * Supports two package structures:
 * 1. globals/globals-pure: Only has index.d.ts, depends on dotnet/dotnet-pure
 * 2. dotnet/dotnet-pure: Has facade pattern with Namespace.d.ts + Namespace/bindings.json
 */
const loadBindingsFromPackage = (
  registry: BindingRegistry,
  packageRoot: string,
  visited: Set<string>
): void => {
  // Avoid cycles
  const absoluteRoot = path.resolve(packageRoot);
  if (visited.has(absoluteRoot)) {
    return;
  }
  visited.add(absoluteRoot);

  // Skip if directory doesn't exist
  if (!fs.existsSync(absoluteRoot)) {
    return;
  }

  // Strategy 1: Look for *.bindings.json manifest files in the package root
  const rootEntries = fs.readdirSync(absoluteRoot, { withFileTypes: true });
  const rootManifests = rootEntries
    .filter((e) => e.isFile() && e.name.endsWith(".bindings.json"))
    .map((e) => path.join(absoluteRoot, e.name));

  for (const manifestPath of rootManifests) {
    loadBindingsFromPath(registry, manifestPath);
  }

  // Strategy 2: Look for Namespace/bindings.json for each Namespace.d.ts facade
  // This supports @tsonic/dotnet structure: System.d.ts facade + System/bindings.json
  const facadeFiles = rootEntries
    .filter((e) => e.isFile() && e.name.endsWith(".d.ts"))
    .map((e) => e.name);

  for (const facadeFile of facadeFiles) {
    // e.g., "System.d.ts" → "System"
    const namespaceName = facadeFile.slice(0, -".d.ts".length);
    const namespaceDir = path.join(absoluteRoot, namespaceName);
    const bindingsPath = path.join(namespaceDir, "bindings.json");

    if (fs.existsSync(bindingsPath)) {
      loadBindingsFromPath(registry, bindingsPath);
    }
  }

  // Strategy 3: Look for *.bindings.json next to each .d.ts file (recursive)
  const declFiles = scanForDeclarationFiles(absoluteRoot);
  for (const declPath of declFiles) {
    const manifestPath = declPath.replace(/\.d\.ts$/, ".bindings.json");
    loadBindingsFromPath(registry, manifestPath);

    // Strategy 4: Look for bindings.json in same directory as index.d.ts
    if (path.basename(declPath) === "index.d.ts") {
      const dirBindings = path.join(path.dirname(declPath), "bindings.json");
      loadBindingsFromPath(registry, dirBindings);
    }
  }

  // Strategy 5: Recursively load bindings from @tsonic/* dependencies
  // This is crucial for packages like @tsonic/globals that depend on @tsonic/dotnet
  // and @tsonic/globals-pure that depends on @tsonic/dotnet-pure
  const packageJsonPath = path.join(absoluteRoot, "package.json");
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      const deps = packageJson.dependencies || {};

      for (const depName of Object.keys(deps)) {
        // Only follow @tsonic/* dependencies to load their bindings
        if (depName.startsWith("@tsonic/")) {
          // Find the dependency in node_modules
          // Try sibling node_modules first (hoisted), then nested
          const nodeModulesDir = path.dirname(path.dirname(absoluteRoot));
          const hoistedPath = path.join(nodeModulesDir, depName);
          const nestedPath = path.join(absoluteRoot, "node_modules", depName);

          if (fs.existsSync(hoistedPath)) {
            loadBindingsFromPackage(registry, hoistedPath, visited);
          } else if (fs.existsSync(nestedPath)) {
            loadBindingsFromPackage(registry, nestedPath, visited);
          }
        }
      }
    } catch {
      // Ignore JSON parse errors in package.json
    }
  }
};

/**
 * Load binding manifests from configured type roots
 * Looks for *.bindings.json files alongside .d.ts files OR directly in typeRoot
 * Also recursively loads bindings from @tsonic/* dependencies of typeRoot packages
 */
export const loadBindings = (typeRoots: readonly string[]): BindingRegistry => {
  const registry = new BindingRegistry();
  const visited = new Set<string>();

  for (const typeRoot of typeRoots) {
    loadBindingsFromPackage(registry, typeRoot, visited);
  }

  return registry;
};

/**
 * Load bindings from a specific file path into an existing registry.
 * Validates the file format and logs a warning if invalid.
 */
export const loadBindingsFromPath = (
  registry: BindingRegistry,
  bindingsPath: string
): void => {
  try {
    if (fs.existsSync(bindingsPath)) {
      const content = fs.readFileSync(bindingsPath, "utf-8");
      const parsed = JSON.parse(content) as unknown;

      // Validate the parsed structure
      const validationError = validateBindingFile(parsed, bindingsPath);
      if (validationError) {
        console.warn(`Invalid bindings file: ${validationError}`);
        return;
      }

      registry.addBindings(bindingsPath, parsed as BindingFile);
    }
  } catch (err) {
    if (err instanceof SyntaxError) {
      console.warn(
        `Failed to parse bindings from ${bindingsPath}: Invalid JSON - ${err.message}`
      );
    } else {
      console.warn(`Failed to load bindings from ${bindingsPath}:`, err);
    }
  }
};

/**
 * Load all CLR bindings discovered by the resolver.
 * This should be called AFTER createProgram but BEFORE IR building
 * to ensure all bindings are available during IR construction.
 *
 * Note: The ClrBindingsResolver tracks discovered binding paths via caching,
 * so this loads bindings for any imports that were already resolved.
 */
export const loadAllDiscoveredBindings = (
  registry: BindingRegistry,
  discoveredPaths: ReadonlySet<string>
): void => {
  for (const bindingsPath of discoveredPaths) {
    loadBindingsFromPath(registry, bindingsPath);
  }
};
