# Bindings Discovery

How Tsonic discovers and loads binding metadata from typings packages.

---

## Overview

Tsonic compiles TypeScript to C# by mapping TypeScript symbols to CLR types. This mapping is defined in **binding files** generated by tsbindgen. The compiler discovers these bindings automatically from packages in the TypeScript program.

**Key principle**: The TypeScript program (via `tsconfig.json`) is the single source of truth for available library surfaces. If a package contributes `.d.ts` files to the program and contains binding metadata, its bindings are loaded.

---

## Discovery Algorithm

### Step 1: Identify Active Packages

From the TypeScript program, identify all `.d.ts` source files that are NOT local project files.

### Step 2: Determine Package Roots

For each external `.d.ts` file, determine its owning `node_modules/<package>` root.

### Step 3: Deduplicate

Deduplicate the list of packages.

### Step 4: Check for Bindings

For each package, check if `internal/bindings.json` exists:
- If yes → load bindings and metadata
- If no → ignore for binding purposes (still used for TypeScript types)

### Pseudocode

```typescript
const discoverBindings = (program: ts.Program): BindingRegistry => {
  const registry = new BindingRegistry();
  const seenPackages = new Set<string>();

  for (const sourceFile of program.getSourceFiles()) {
    // Skip local project files
    if (!sourceFile.fileName.includes('node_modules')) continue;

    // Extract package name from path
    const packageRoot = getPackageRoot(sourceFile.fileName);
    if (seenPackages.has(packageRoot)) continue;
    seenPackages.add(packageRoot);

    // Check for bindings file
    const bindingsPath = path.join(packageRoot, 'internal', 'bindings.json');
    if (fs.existsSync(bindingsPath)) {
      const bindings = JSON.parse(fs.readFileSync(bindingsPath, 'utf-8'));
      registry.loadPackage(packageRoot, bindings);
    }
  }

  return registry;
};
```

---

## Package Structure (tsbindgen Output)

tsbindgen generates packages with the following structure:

```
node_modules/@types/dotnet/
├── package.json
├── tsconfig.json
├── internal/
│   ├── bindings.json          # Root bindings file (marker + data)
│   ├── metadata.json          # Additional metadata
│   └── extensions/
│       └── index.d.ts         # Extension method bucket interfaces
├── System/
│   ├── index.d.ts             # System namespace types
│   ├── index.js               # Module stub
│   ├── bindings.json          # Namespace-specific bindings
│   └── internal/
│       ├── index.d.ts         # Internal type details
│       └── metadata.json      # Namespace metadata
├── System.IO/
│   ├── index.d.ts
│   ├── index.js
│   ├── bindings.json
│   └── internal/
│       ├── index.d.ts
│       └── metadata.json
├── System.Linq/
│   └── ...
└── ... (100+ namespace directories)
```

### Key Files

| File | Purpose |
|------|---------|
| `internal/bindings.json` | Root bindings file - presence indicates this is a Tsonic binding package |
| `internal/metadata.json` | Additional type metadata (generics, constraints, etc.) |
| `internal/extensions/index.d.ts` | Extension method bucket interfaces and `ExtensionMethods<T>` helper |
| `<Namespace>/bindings.json` | Per-namespace binding data |
| `<Namespace>/internal/metadata.json` | Per-namespace metadata with method signatures |

---

## Bindings File Format

### Root bindings.json

```json
{
  "packageName": "@types/dotnet",
  "version": "1.0.0",
  "generator": "tsbindgen",
  "generatorVersion": "1.0.0",
  "namespaces": [
    "System",
    "System.IO",
    "System.Linq",
    "System.Collections.Generic"
  ]
}
```

### Namespace bindings.json

```json
{
  "namespace": "System.Linq",
  "types": [
    {
      "stableId": "System.Linq:System.Linq.Enumerable",
      "clrName": "System.Linq.Enumerable",
      "tsEmitName": "Enumerable",
      "assemblyName": "System.Linq",
      "methods": [...],
      "properties": [...],
      "fields": [...],
      "exposedMethods": [...]
    }
  ]
}
```

### Metadata.json (per namespace)

```json
{
  "types": [
    {
      "stableId": "System.Linq:System.Linq.Enumerable::Where(IEnumerable_1,Func_2):IEnumerable_1",
      "clrName": "Where",
      "tsEmitName": "Where",
      "normalizedSignature": "Where|(IEnumerable_1,Func_2):IEnumerable_1|static=true",
      "isStatic": true,
      "isExtensionMethod": true,
      "arity": 1,
      "parameterCount": 2
    }
  ]
}
```

---

## StableId Format

The `stableId` uniquely identifies a CLR member:

```
{Assembly}:{DeclaringType}::{MemberName}({ParamTypes}):{ReturnType}
```

Examples:
- Type: `System.Linq:System.Linq.Enumerable`
- Method: `System.Linq:System.Linq.Enumerable::Where(IEnumerable_1,Func_2):IEnumerable_1`
- Field: `System.Linq:System.Linq.ParallelExecutionMode::DefaultSystem.Linq.ParallelExecutionMode`

---

## Extension Methods

Extension methods are identified in metadata by:

```json
{
  "isExtensionMethod": true,
  "isStatic": true
}
```

The `stableId` contains the declaring class (e.g., `System.Linq.Enumerable`), and the `normalizedSignature` contains the target type (first parameter).

See [Extension Methods](../reference/dotnet/extension-methods.md) for how extension methods are emitted.

---

## Mode and Built-in Methods

Binding discovery is **independent of mode**. Both `mode: "dotnet"` and `mode: "js"` load the same bindings.

Mode affects only how **built-in methods** (Array, String, Math, console) are lowered:
- `mode: "dotnet"` → uses BCL method names from bindings
- `mode: "js"` → uses `Tsonic.JSRuntime` extension methods

The built-in method list is hardcoded in the compiler, not derived from bindings.

See [Configuration - Mode Semantics](../configuration.md#mode-semantics) for details.

---

## Future Extensibility

This discovery mechanism supports future "stdlibs" without compiler changes:

1. **nodejs-clr**: Install `@types/nodejs-clr`, add to `typeRoots`
2. **python-clr**: Install `@types/python-clr`, add to `typeRoots`
3. **Custom bindings**: Any tsbindgen output with `internal/bindings.json`

The compiler treats all binding packages uniformly - no special-casing for "dotnet" vs other surfaces.

---

## Error Conditions

### No Bindings Found

If the TypeScript program has no packages with `internal/bindings.json`:

```
TSN9001: No binding packages found. Install @types/dotnet or another
tsbindgen-generated package and add it to tsconfig.json typeRoots.
```

### Invalid Bindings Format

If `internal/bindings.json` exists but is malformed:

```
TSN9002: Invalid bindings file in package '@types/dotnet':
Expected 'namespace' field in System.Linq/bindings.json
```

### Missing Namespace Bindings

If a namespace directory exists but has no `bindings.json`:

```
TSN9003: Namespace 'System.Linq' has types but no bindings.json.
This may indicate an incomplete tsbindgen output.
```

---

## Implementation Notes

### Performance

- Bindings are loaded once at program creation
- Metadata is loaded lazily per-namespace on first use
- Consider caching parsed bindings across incremental builds

### Validation

- Validate bindings schema on load
- Warn on version mismatches between compiler and tsbindgen output
- Skip invalid packages rather than failing entire compilation

### Debugging

Add verbose logging for binding discovery:

```bash
tsonic build --verbose
# Outputs: Discovered bindings: @types/dotnet (127 namespaces)
```

---

## See Also

- [Configuration](../configuration.md) - tsonic.json and tsconfig.json setup
- [Extension Methods](../reference/dotnet/extension-methods.md) - How extension methods are handled
- [Architecture: IR Building](../architecture/05-phase-ir.md) - Where binding resolution happens
