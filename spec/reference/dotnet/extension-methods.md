# Extension Methods

Using C# extension methods (especially LINQ) from TypeScript code compiled by Tsonic.

---

## Overview

C# extension methods allow adding methods to existing types without modifying them. LINQ methods like `Where`, `Select`, `Aggregate` are extension methods on `IEnumerable<T>`. Tsonic compiles TypeScript code using these methods to proper C# static method calls.

**Key Concept**: In C#, `numbers.Where(...)` is syntactic sugar for `Enumerable.Where(numbers, ...)`. Tsonic performs the same transformation during compilation.

---

## How Extension Methods Work in C#

### Definition

```csharp
// Extension methods are static methods in static classes
// First parameter has 'this' modifier
public static class Enumerable  // in System.Linq
{
    public static IEnumerable<T> Where<T>(
        this IEnumerable<T> source,  // 'this' = extended type
        Func<T, bool> predicate
    ) { ... }
}
```

### C# Compilation

```csharp
// What you write (syntactic sugar):
var evens = numbers.Where(x => x % 2 == 0);

// What C# compiler emits:
var evens = Enumerable.Where(numbers, x => x % 2 == 0);
```

---

## Using Extension Methods in TypeScript

### The Rich<T> Pattern

tsbindgen generates type declarations that expose extension methods via a type intersection pattern:

```typescript
import { IEnumerable_1 } from "@tsonic/dotnet/System.Collections.Generic";
import { ExtensionMethods } from "@tsonic/dotnet";

// Rich<T> adds extension methods to any type
type Rich<T> = T & ExtensionMethods<T>;

// Usage - TypeScript sees all extension methods
const nums: Rich<IEnumerable_1<int>> = getNumbers();
nums.Where((x) => x > 0); // TypeScript knows this method exists
nums.Select((x) => x * 2); // Fully typed with IntelliSense!
```

### How ExtensionMethods<T> Works

tsbindgen generates bucket interfaces containing extension methods for each target type:

```typescript
// Generated by tsbindgen in internal/extensions/index.d.ts
export interface __Ext_IEnumerable_1<T> {
  Aggregate<TSource>(func: Func_3<TSource, TSource, TSource>): TSource;
  Any<TSource>(): boolean;
  Where<TSource>(predicate: Func_2<TSource, boolean>): IEnumerable_1<TSource>;
  Select<TSource, TResult>(
    selector: Func_2<TSource, TResult>
  ): IEnumerable_1<TResult>;
  // ... 250+ LINQ methods
}

// Conditional type maps shapes to buckets
export type ExtensionMethods<TShape> = TShape extends IEnumerable_1<infer T>
  ? __Ext_IEnumerable_1<T>
  : TShape extends String
    ? __Ext_String
    : TShape extends Span_1<infer T>
      ? __Ext_Span_1<T>
      : // ... 100+ more mappings
        {};
```

---

## Full Example

### TypeScript Input

```typescript
import { IEnumerable_1 } from "@tsonic/dotnet/System.Collections.Generic";
import { ExtensionMethods } from "@tsonic/dotnet";
import { int } from "@tsonic/types";

type Rich<T> = T & ExtensionMethods<T>;

function processNumbers(
  nums: Rich<IEnumerable_1<int>>
): Rich<IEnumerable_1<int>> {
  return nums
    .Where((x) => x > 0)
    .Select((x) => x * 2)
    .OrderBy((x) => x);
}
```

### Generated C#

```csharp
using System.Linq;
using System.Collections.Generic;

public static IEnumerable<int> processNumbers(IEnumerable<int> nums)
{
    return Enumerable.OrderBy(
        Enumerable.Select(
            Enumerable.Where(nums, x => x > 0),
            x => x * 2
        ),
        x => x
    );
}
```

---

## Common LINQ Methods

### Filtering

```typescript
// Where - filter elements
const evens = nums.Where((x) => x % 2 === 0);

// Distinct - remove duplicates
const unique = nums.Distinct();

// Take/Skip - pagination
const first10 = nums.Take(10);
const after10 = nums.Skip(10);
```

### Transformation

```typescript
// Select - transform each element
const doubled = nums.Select((x) => x * 2);

// SelectMany - flatten nested collections
const allItems = orders.SelectMany((o) => o.items);

// Cast - convert element types
const objects = nums.Cast<object>();
```

### Aggregation

```typescript
// Count, Sum, Average, Min, Max
const count = nums.Count();
const sum = nums.Sum();
const avg = nums.Average();

// Aggregate - custom reduction
const product = nums.Aggregate((acc, x) => acc * x);

// First, Last, Single (with optional predicates)
const first = nums.First();
const lastEven = nums.Last((x) => x % 2 === 0);
```

### Ordering

```typescript
// OrderBy/OrderByDescending
const sorted = nums.OrderBy((x) => x);
const descending = nums.OrderByDescending((x) => x);

// ThenBy - secondary sort
const byNameThenAge = people.OrderBy((p) => p.name).ThenBy((p) => p.age);
```

### Grouping & Joining

```typescript
// GroupBy
const byCategory = products.GroupBy((p) => p.category);

// Join
const joined = orders.Join(
  customers,
  (o) => o.customerId,
  (c) => c.id,
  (o, c) => ({ order: o, customer: c })
);
```

### Conversion

```typescript
// ToList, ToArray
const list = nums.ToList();
const array = nums.ToArray();

// ToDictionary
const byId = users.ToDictionary((u) => u.id);
```

---

## Handling Overloads

Many LINQ methods have multiple overloads. tsbindgen generates unique names:

```typescript
// In TypeScript bucket interface
interface __Ext_IEnumerable_1<T> {
  Where<TSource>(predicate: Func_2<TSource, boolean>): IEnumerable_1<TSource>;
  Where2<TSource>(
    predicate: Func_3<TSource, int, boolean>
  ): IEnumerable_1<TSource>; // With index
}
```

Both compile to `Enumerable.Where(...)` in C# - the compiler resolves based on argument types.

```typescript
// Usage
nums.Where((x) => x > 0); // Simple predicate
nums.Where2((x, i) => i % 2 === 0); // With index parameter
```

---

## Extension Methods on Other Types

### String Extensions

```typescript
type RichString = string & ExtensionMethods<string>;

const str: RichString = "hello world";
const span = str.AsSpan();
const memory = str.AsMemory();
```

### Span/Memory Extensions

```typescript
type RichSpan<T> = Span_1<T> & ExtensionMethods<Span_1<T>>;

const span: RichSpan<int> = getSpan();
span.Fill(0);
span.CopyTo(destination);
```

---

## Chained Extension Calls

Each call in a chain is independently resolved:

```typescript
// TypeScript
nums.Where((x) => x > 0)
  .Select((x) => x * 2)
  .OrderBy((x) => x)
  .ToList();
```

```csharp
// Generated C# - nested static calls
Enumerable.ToList(
    Enumerable.OrderBy(
        Enumerable.Select(
            Enumerable.Where(nums, x => x > 0),
            x => x * 2
        ),
        x => x
    )
);
```

---

## Metadata Format

tsbindgen emits metadata that Tsonic uses to resolve extension methods:

```json
{
  "stableId": "System.Linq:System.Linq.Enumerable::Where(IEnumerable_1,Func_2):IEnumerable_1",
  "clrName": "Where",
  "tsEmitName": "Where",
  "normalizedSignature": "Where|(IEnumerable_1,Func_2):IEnumerable_1|static=true",
  "isStatic": true,
  "isExtensionMethod": true,
  "arity": 1,
  "parameterCount": 2
}
```

**Key fields:**

| Field               | Purpose                                                |
| ------------------- | ------------------------------------------------------ |
| `isExtensionMethod` | Identifies this as an extension method                 |
| `stableId`          | Contains declaring class: `System.Linq.Enumerable`     |
| `normalizedSignature` | Contains target type: `IEnumerable_1`                |
| `clrName`           | The actual C# method name to emit                      |
| `tsEmitName`        | TypeScript name (may differ for overloads: `Where2`)   |

---

## Resolution Priority

When multiple extension methods could apply:

1. **Exact type match**: `List<T>` extensions before `IEnumerable<T>` extensions
2. **Most specific interface**: `IList<T>` before `IEnumerable<T>`
3. **First found**: If still ambiguous, use first match in metadata order

---

## Combining with ref/out Parameters

Some extension methods use ref parameters (e.g., `Span<T>` methods):

```typescript
import { ref, out } from "@tsonic/types";

// Extension method with ref parameter
span.TryWrite(ref(handler), out(charsWritten));
```

See [ref-out.md](ref-out.md) for details on ref/out parameter handling.

---

## Best Practices

### 1. Use Rich<T> Consistently

```typescript
// Define Rich<T> once
type Rich<T> = T & ExtensionMethods<T>;

// Use for all .NET collection types
function process(nums: Rich<IEnumerable_1<int>>): Rich<List_1<int>> {
  return nums.Where((x) => x > 0).ToList();
}
```

### 2. Import ExtensionMethods from Central Location

```typescript
// In a shared types file
import { ExtensionMethods } from "@tsonic/dotnet";

export type Rich<T> = T & ExtensionMethods<T>;

// Re-export for use across your codebase
```

### 3. Check Return Types

LINQ methods often return `IEnumerable<T>` which is lazy. Call `ToList()` or `ToArray()` when you need materialized results:

```typescript
// Lazy - not executed yet
const filtered = nums.Where((x) => x > 0);

// Materialized - executed and stored
const list = nums.Where((x) => x > 0).ToList();
```

---

## Limitations

1. **No custom extension methods yet**: Currently only supports extension methods from tsbindgen-generated bindings
2. **Type inference**: Complex generic scenarios may require explicit type annotations
3. **Performance**: Chained calls become nested in C# - consider materializing intermediate results for debugging

---

## See Also

- [.NET Integration Overview](../../dotnet-reference.md) - General .NET interop
- [Type Mappings](type-mappings.md) - TypeScript to C# type conversions
- [Ref/Out Parameters](ref-out.md) - Using ref/out with extension methods
- [Architecture: IR Building](../../architecture/05-phase-ir.md) - How extension calls are detected
- [Architecture: C# Emission](../../architecture/07-phase-emitter.md) - How extension calls are emitted
