# .NET Interop Infrastructure - Implementation Status

**Date**: 2025-11-21
**Branch**: `feat/dotnet-interop-infrastructure`

## Overview

This document summarizes the .NET interop infrastructure that has been built to support loading and using metadata/bindings from external .NET libraries (generated by `tsbindgen`).

## âœ… Completed Infrastructure

### 1. Metadata and Bindings Type System

**Location**: `packages/frontend/src/types/`

- **`metadata.ts`**: TypeScript types matching tsbindgen's `.metadata.json` schema
  - `MetadataFile`, `TypeMetadata`, `MethodMetadata`, `PropertyMetadata`, etc.
  - Uses camelCase properties (JavaScript convention)
  - Captures CLR type information including ref/out/in parameters

- **`bindings.ts`**: TypeScript types for `.bindings.json` schema
  - V1 format: Definition bindings
  - V2 format: Exposure bindings for runtime dispatch
  - `BindingsFile`, `DefinitionBinding`, `ExposureBinding`, `TypeBinding`

### 2. File Loaders

**Location**: `packages/frontend/src/metadata/`

- **`loader.ts`**: Metadata file loading
  - `loadMetadataFile(filePath)`: Load single `.metadata.json`
  - `loadMetadataDirectory(dirPath)`: Load all metadata files from directory
  - Returns `Result<MetadataFile[], Diagnostic[]>`

- **`bindings-loader.ts`**: Bindings file loading
  - `loadBindingsFile(filePath)`: Load single `.bindings.json`
  - `loadBindingsDirectory(dirPath)`: Load all bindings files
  - `buildBindingsRegistry(files)`: Build lookup map by TypeScript emit name
  - `lookupTypeBinding(registry, name)`: O(1) type binding lookup

- **`library-loader.ts`**: **NEW** - Unified library loading
  - `loadLibrary(libraryPath)`: Auto-discovers `.metadata/` and `.bindings/` subdirectories
  - `loadLibraries(paths[])`: Loads from multiple library paths and merges results
  - Returns unified `LibraryData` with both metadata and bindings
  - Proper diagnostic aggregation across all libraries

### 3. Support Type Detection

**Location**: `packages/frontend/src/types/support-types.ts`

- Detects special TypeScript wrapper types:
  - `TSByRef<T>` - For ref/out parameters (supported)
  - `TSNullable<T>` - For nullable value types (supported)
  - `TSDelegate<T>` - For .NET delegates (supported)
  - `TSUnsafePointer<T>` - Unsafe pointers (unsupported - error)
  - `TSFixed<T>` - Fixed buffers (unsupported - error)
  - `TSStackAlloc<T>` - Stack allocation (unsupported - error)

- Functions:
  - `getSupportTypeInfo(type, checker)`: Extract support type info from ts.Type
  - `checkUnsupportedSupportType(type, checker)`: Validate support types
  - **Key fix**: Handles type aliases with `aliasSymbol` and `aliasTypeArguments`

### 4. Nested Type Handling

**Location**: `packages/frontend/src/types/nested-types.ts`

- Handles CLR nested type naming conventions:
  - CLR: `Outer+Inner` (plus separator)
  - TypeScript: `Outer$Inner` (dollar separator)
  - C#: `Outer.Inner` (dot separator)

- Functions:
  - `isNestedType(name)`: Detect $ separator
  - `parseNestedTypeName(name)`: Extract parent/child parts
  - `tsCSharpNestedTypeName(tsName)`: Convert `Outer$Inner` â†’ `Outer.Inner`
  - `clrToTsNestedTypeName(clrName)`: Convert CLR to TypeScript convention

### 5. Explicit Interface Views

**Location**: `packages/frontend/src/types/explicit-views.ts`

- Handles explicit interface implementations:
  - TypeScript: `obj.As_IInterface.Method()`
  - C#: `((IInterface)obj).Method()`

- Functions:
  - `isExplicitViewProperty(name)`: Detect `As_` prefix
  - `extractInterfaceNameFromView(name)`: Extract interface name
  - `generateInterfaceCast(obj, interfaceName)`: Generate C# cast

### 6. Ref/Out Parameter Handling

**Location**: `packages/frontend/src/types/ref-parameters.ts`

- Utilities for CLR ref/out/in parameters:
  - `getParameterModifier(param)`: Extract modifier from metadata
  - `requiresTSByRef(param)`: Check if TSByRef wrapper needed
  - `generateCSharpParameter(modifier, type, name)`: Generate C# param
  - `generateCSharpArgument(modifier, expr)`: Generate C# argument

### 7. CLI Integration

**Location**: `packages/cli/src/`

- **Parser** (`cli/parser.ts`):
  - Added `-L` / `--lib` flag
  - Accumulates multiple library paths into array
  - Example: `tsonic build app.ts -L ./libs/dotnet -L ./libs/custom`

- **Config** (`config.ts`):
  - Merges libraries from `tsonic.json` and CLI flags
  - Config: `dotnet.libraries: string[]`
  - Resolved: `libraries: readonly string[]`

- **Types** (`types.ts`):
  - `CliOptions.lib?: string[]`
  - `TsonicConfig.dotnet.libraries?: readonly string[]`
  - `ResolvedConfig.libraries: readonly string[]`

- **Commands** (`commands/emit.ts`, `build.ts`, `pack.ts`):
  - All commands pass `libraries` to emitter options

### 8. Emitter Integration

**Location**: `packages/emitter/src/`

- **Options** (`emitter-types/core.ts`):
  - Changed from separate `metadataPath` / `bindingsPath`
  - Now: `libraries?: readonly string[]`

- **Context** (`emitter-types/context.ts`):
  - `createContext()` uses `loadLibraries()` for unified loading
  - Loads metadata and bindings from all library paths
  - Builds bindings registry
  - Stores in context for emission use
  - Console warning on load failures (diagnostic integration pending)

### 9. Test Infrastructure

**Location**: `packages/frontend/src/types/test-harness.ts`

- Creates real TypeScript programs for testing
- Compiles support type definitions from `@tsonic/dotnet`
- Extracts real `ts.Type` objects for validation
- Replaces mock types with actual TypeScript Compiler API types

### 10. Diagnostic Codes

**Location**: `packages/frontend/src/types/diagnostic.ts`

- Added TSN9001-TSN9114 for metadata/bindings loading errors
- Example codes:
  - TSN9001: Metadata file not found
  - TSN9016: Library directory not found
  - TSN9017: Library path is not a directory

## ğŸ“‹ Architecture Summary

```
User Code (TypeScript)
    â†“
tsonic build app.ts --lib ./libs/dotnet
    â†“
CLI (packages/cli)
â”œâ”€â”€ Parser: -L/--lib flags â†’ options.lib[]
â”œâ”€â”€ Config: Merge config + CLI â†’ ResolvedConfig.libraries[]
â””â”€â”€ Commands: Pass libraries to emitter
    â†“
Emitter (packages/emitter)
â”œâ”€â”€ createContext(options)
â”‚   â””â”€â”€ loadLibraries(options.libraries)
â”‚       â”œâ”€â”€ For each library path:
â”‚       â”‚   â”œâ”€â”€ Load .metadata/*.metadata.json
â”‚       â”‚   â””â”€â”€ Load .bindings/*.bindings.json
â”‚       â””â”€â”€ Merge all metadata + bindings
â””â”€â”€ EmitterContext
    â”œâ”€â”€ metadata: MetadataFile[]
    â””â”€â”€ bindingsRegistry: Map<string, TypeBinding>
        â†“
    (Available for emission decisions)
```

## ğŸ”„ Library Directory Structure

```
library-path/
â”œâ”€â”€ .metadata/
â”‚   â”œâ”€â”€ System.metadata.json
â”‚   â”œâ”€â”€ System.Collections.metadata.json
â”‚   â””â”€â”€ System.Linq.metadata.json
â””â”€â”€ .bindings/
    â”œâ”€â”€ System.bindings.json
    â”œâ”€â”€ System.Collections.bindings.json
    â””â”€â”€ System.Linq.bindings.json
```

Single `--lib` flag points to library root, auto-discovers subdirectories.

## â³ Future Work (Not Yet Implemented)

### 1. Import Resolution Using Metadata

**What**: Validate .NET imports against loaded metadata during IR building

**Example**:
```typescript
import { File } from "System.IO";  // Verify File exists in System.IO metadata
```

**Where**: `packages/frontend/src/ir/builder/imports.ts`

**Requires**:
- Access to metadata in IR builder context
- Lookup function to find type in metadata by namespace + name
- Diagnostic reporting for missing types

### 2. Emission Guards Using Metadata

**What**: Consult metadata before emitting method calls to handle special cases

**Example**:
```typescript
// If metadata says method has ref parameter:
int.TryParse(str, out value)
// Emit as:
int value;
int.TryParse(str, out value)
```

**Where**: `packages/emitter/src/expressions/call.ts`

**Requires**:
- Metadata lookup during call emission
- Ref/out parameter detection from metadata
- IR transformation to handle output parameters

### 3. Type System Integration for Ref/Out Detection

**What**: During IR building, detect ref/out parameters from metadata and mark in IR

**Example**:
```typescript
// IR should mark that 'value' is an out parameter
const result = int.TryParse(str, value);
// IR node:
{
  kind: "call",
  arguments: [
    { expr: str },
    { expr: value, modifier: "out" }  // â† Detected from metadata
  ]
}
```

**Where**: `packages/frontend/src/ir/expression-converter.ts`

**Requires**:
- Metadata passed to IR builder
- Type lookup for call expressions
- IR nodes extended to capture parameter modifiers

### 4. Proper Diagnostic Collection

**What**: Collect and return diagnostics instead of console.warn

**Example**:
```typescript
export type EmitResult = {
  files: Map<string, string>;
  diagnostics: Diagnostic[];
};
```

**Where**: `packages/emitter/src/emitter.ts`

**Requires**:
- Change return type of emitCSharpFiles
- Thread diagnostic collector through emission
- Update CLI to report emitter diagnostics

## ğŸ“Š Current System Comparison

### OLD Binding System (Currently Active)
- **Location**: `packages/frontend/src/program/bindings.ts`
- **Purpose**: Map TypeScript identifiers to CLR types at compile time
- **Format**: Custom binding manifest format
- **Loaded from**: Type roots directories (node_modules/@types/...)
- **Used by**: IR builder for import resolution and identifier binding

### NEW Metadata/Bindings System (Infrastructure Ready)
- **Location**: `packages/frontend/src/metadata/`
- **Purpose**: Load complete .NET type metadata for emission decisions
- **Format**: tsbindgen-generated `.metadata.json` and `.bindings.json`
- **Loaded from**: Library directories via `--lib` flag
- **Used by**: *Not yet integrated* - Infrastructure ready, usage pending

### Integration Strategy

The two systems serve different purposes:
- **OLD**: Compile-time binding resolution (TypeScript â†’ CLR mapping)
- **NEW**: Runtime metadata for emission decisions (ref/out, method signatures, etc.)

They can coexist. Future integration would:
1. Keep OLD system for basic import resolution
2. Use NEW system for advanced emission features (ref/out, delegates, etc.)
3. Eventually migrate OLD system to use tsbindgen format

## ğŸ§ª Test Status

All 341 tests passing:
- Backend: 9 passing
- CLI: 63 passing
- Emitter: 110 passing
- Frontend: 159 passing

### Key Test Coverage

1. **Metadata/Bindings Loading**:
   - `metadata/loader.test.ts`: File and directory loading
   - `metadata/bindings-loader.test.ts`: Bindings registry building
   - Error handling for invalid files

2. **Support Types**:
   - `types/support-types.test.ts`: Detection with real ts.Type objects
   - Uses test harness for realistic type checking

3. **Nested Types**:
   - `types/nested-types.test.ts`: Name conversion CLR â†” TypeScript â†” C#

4. **Ref Parameters**:
   - `types/ref-parameters.test.ts`: Modifier detection and C# generation

5. **CLI Integration**:
   - Parser tests for `-L`/`--lib` flag accumulation
   - Config tests for library merging

## ğŸ“ Summary

### What We Built

âœ… **Complete infrastructure for loading .NET metadata and bindings**:
- Type-safe TypeScript definitions for tsbindgen schemas
- File loaders with proper error handling
- Library-loader pattern with auto-discovery
- CLI integration with `--lib` flag
- Emitter context integration
- Support for ref/out parameters, nested types, explicit interfaces
- Comprehensive test coverage

### What Remains

â³ **Feature implementations that USE the infrastructure**:
- Import validation against metadata
- Emission guards for method calls
- Type system hooks for ref/out detection
- Diagnostic collection and reporting

### Next Steps

When ready to implement actual .NET interop features:

1. **Start with import validation**: Simplest use case, validates imports against metadata
2. **Add emission guards**: Enhance method call emission with metadata checks
3. **Integrate with IR builder**: Detect ref/out during IR building
4. **Enhance diagnostics**: Proper collection instead of console.warn

The infrastructure is complete and tested. Future features can now build on this foundation.
